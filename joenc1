#! /usr/bin/env python
# by pts@fazekas.hu at Sun Jun  6 18:06:47 CEST 2010

"""Start joe(1) opening and encrypting a single file.

Example old command:

  joe [-beep] file1 file2 file3

Example new command, with automatic decryption on load and encryption on save.

  $ touch encrypted-file1
  $ joenc1 [-beep] encrypted-file1 file2 file3
  joenc1 passphrase for 'encrypted-file1':

Example setup for SSH signing:

  # Create encrypted-file1 just as above (pick a passphrase, can be random).
  # Start ssh-agent and make sure you have a working $SSH_AUTH_SOCK .
  # Don't put whitespace in the comment below:
  $ ssh-keygen -t rsa -b 4096 -C 'my-joenc1-key' -f keyfile
  # You may or may not have an SSH key passphrase here.
  $ ssh-add keyfile
  $ cp keyfile.pub encrypted-file1.akey
  $ joenc1 -getfixup encrypted-file1
  # Type encrypted-file1 passphrase.
  # Copy-paste the printed output back to encrypted-file1.
  $ joenc1 encrypted-file1
  # This should not ask for the encrypted-file1 passphrase (but it should
  # for the SSH key passphrase).
"""

__author__ = 'pts@fazekas.hu (Peter Szabo)'

import base64
import cStringIO
import errno
import fcntl
import getpass
import hmac
import os
import os.path
import re
import socket
import stat
import struct
import subprocess
import sys
import thread
import time
import traceback


# SHA-1 (160 bit output), available since Python2.4 (or earlier).
try:
  import hashlib  # No deprecation warning in Python 2.6.
  sha1 = hashlib.sha1
except (ImportError, AttributeError):
  from sha import sha as sha1

sha1_module = type(sys)('sha1_module')
sha1_module.new = sha1
sha1_module.digest_size = 20

# Just a quick sanity check.
assert 'c387b401c957209a84d581a23247f9199292a052' == hmac.new(
    'mykey', 'mymsg', sha1_module).hexdigest()
m = hmac.new('mykey', None, sha1_module)
m.update('mymsg')
assert 'c387b401c957209a84d581a23247f9199292a052' == m.hexdigest()



HEADER_START = '\0J1\x1A/'  # '.' is the first version.

PASSPHRASE_FD = 62
"""File descriptor openssl can read to get the passphrase."""

def PassphraseSender(read_fd, write_fd, passphrasen):
  # Exceptions raised here a lost (not reported to joe).
  if not isinstance(passphrasen, str):
    raise TypeError
  while True:
    os.read(read_fd, 1)
    got = os.write(write_fd, passphrasen)
    assert got == len(passphrasen)

def ErrorWrapper(function, *args, **kwargs):
  try:
    return function(*args, **kwargs)
  except:
    # TODO(pts): Print the caller as well.
    typ, exc, tb = sys.exc_info()
    traceback.print_exception(typ, exc, tb.tb_next)
    return None

def JoeFileWorker(np_write_fd, encfile):
  """Called when this program was invoked by joe through `!file'."""
  tty_fd = os.open('/dev/tty', os.O_WRONLY)
  if tty_fd != 2:
    os.dup2(tty_fd, 2)
    os.close(tty_fd)

  try:
    st0 = os.fstat(0)
    st1 = os.fstat(1)
    if stat.S_ISFIFO(st1.st_mode) and not stat.S_ISFIFO(st0.st_mode):
      fd = os.open(encfile, os.O_RDONLY)
      header = os.read(fd, 32)
      if header:
        if len(header) < 32 or not header.startswith(HEADER_START):
          assert 0, ('error: unrecognized header %s' %
                     header.encode('hex'))
        expected_hmac = header[12 : 32]
        os.write(np_write_fd, 'W')
        passphrasen = os.read(PASSPHRASE_FD, 4096)
        i = passphrasen.find('\n')
        assert i == len(passphrasen) - 1
        hmac_obj = hmac.new(passphrasen[:-1], None, sha1_module)
        passphrasen = None
        if fd > 9:  # Some shells (e.g. dash) can't redirect to multi-digit.s
          os.dup2(fd, 3)
          os.close(fd)
          fd = 3
        # Ask the parent to write the passphrase for openssl below.
        os.write(np_write_fd, 'W')
        rf = os.popen(
            'openssl enc -aes-256-cbc -salt -d -pass fd:%s <&%d' %
            (PASSPHRASE_FD, fd), 'r')
        rfd = rf.fileno()
        output = []
        while True:
          data = os.read(rfd, 8192)
          if not data:
            break
          hmac_obj.update(data)
          output.append(data)
        got_hmac = hmac_obj.digest()
        if  expected_hmac != got_hmac:
          # Don't write anything until hmac is proven correct.
          # We may also display an OpenSSL error above.
          assert 0, 'hmac mismatch: %s' % encfile
        output = ''.join(output)
        got = os.write(1, output)
        while got < len(output):
          output = buffer(output, got)
          got = os.write(1, output)
        #os.write(1, 'READ FILE TO JOE')
    elif stat.S_ISFIFO(st0.st_mode) and not stat.S_ISFIFO(st1.st_mode):
      # TODO(pts): Better write error handling.
      #open('save.dat', 'w').write(time.ctime() + '\n' + sys.stdin.read())
      os.write(np_write_fd, 'W')
      passphrasen = os.read(PASSPHRASE_FD, 4096)
      i = passphrasen.find('\n')
      assert i == len(passphrasen) - 1
      hmac_obj = hmac.new(passphrasen[:-1], None, sha1_module)
      passphrasen = None
      os.write(np_write_fd, 'W')
      # Write the header.
      fd = os.open(encfile, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0644)
      if fd != 1:
        os.dup2(fd, 1)
        os.close(fd)
      assert 32 == os.write(1, '\0J1\x1A/56789AB((((SHA1CHECKSUM))))')
      wf = os.popen(
          'openssl enc -aes-256-cbc -salt -pass fd:%s' % PASSPHRASE_FD, 'w')
      wfd = wf.fileno()
      while True:
        data = os.read(0, 8192)
        if not data:
          break
        hmac_obj.update(data)
        got = os.write(wfd, data)
        while got < len(data):
          data = buffer(data, got)
          got = os.write(wfd, data)
      assert not wf.close(), 'openssl failed'
      os.lseek(1, 12, 0)
      assert 20 == os.write(1, hmac_obj.digest())
      # TODO(pts): Better error reporting on assertion failure here.
    else:
      assert 0, 'error: invalid pipe invocation'
  except SystemExit:
    pass
  except:
    typ, exc, tb = sys.exc_info()
    os.close(1)
    if not os.fork():  # Report in a child process, so joe doesn't wait for it.
      time.sleep(0.3)
      if isinstance(exc, AssertionError):
        os.write(2, 'joenc1 ERROR: %s\r' % exc)
      else:
        os.write(2, 'joenc1 EXC: %s: %s\r' % (type(exc).__name__, exc))
      os._exit(3)

def ShowUsage(): 
  print >>sys.stderr, (
      'Usage: %s [<joe-flag> ...] <encfile> [<file> ...]' % sys.argv[0])

def QuoteShellWord(word):
  """Quote a word from /bin/sh (Bourne shell)."""
  if re.match(r'[-:,@%=+/.\w][-:,~@%^={}+/.\w]*\Z', word):
    return word
  else:
    return "'%s'" % word.replace("'", "'\\''")


def FindOnPath(binary):
  if '/' in binary:
    return binary
  for dir_name in os.getenv('PATH', '/bin:/usr/bin').split(':'):
    if dir_name:
      file_name = os.path.join(dir_name, binary)
      if os.path.isfile(file_name):
        return file_name
  return None

PREP = {
    'salt1': 'foo',
    'salt2': 'bar',
    'num_iterations': 1903,
    'salt1_rsa': 'baz',
    'salt2_rsa': 'quux',
    'num_iterations_before_rsa_fix': 951,
}
"""Parameters of preprocessing."""


def PreprocessPassphrase(passphrase):
  salt1 = PREP['salt1']
  salt2 = PREP['salt2']
  data = passphrase
  for i in xrange(PREP['num_iterations']):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  return data.encode('base64').rstrip('\n')


def StrXor(s1, s2):
  # PyCrypto has a faster implementation (but Python 2.6 doesn't), but we don't care much here, because
  # we don't call StrXor in an inner loop.
  return ''.join(map(lambda x, y: chr(ord(x) ^ ord(y)), s1, s2))


def PreprocessRsaSignature(signature, fixup):
  assert len(fixup) == 40
  assert len(signature) >= 40
  salt1 = PREP['salt1_rsa']
  salt2 = PREP['salt2_rsa']
  data = signature[-40:]
  n1 = PREP['num_iterations_before_rsa_fix']
  n2 = PREP['num_iterations']
  # It would work (but may be cryptographically weaker with <= instead of <).
  assert 0 < n1 < n2
  for i in xrange(n1):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  assert len(data) == 40
  data = StrXor(data, fixup)
  salt1 = PREP['salt1']
  salt2 = PREP['salt2']
  for i in xrange(n1, n2):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  return data.encode('base64').rstrip('\n')


def GetFixup(passphrase, signature):
  """Compute and return the binary fixup= value for the .akeys file."""
  assert len(signature) >= 40
  n1 = PREP['num_iterations_before_rsa_fix']
  salt1 = PREP['salt1']
  salt2 = PREP['salt2']
  data = passphrase
  for i in xrange(n1):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  middle = data
  salt1 = PREP['salt1_rsa']
  salt2 = PREP['salt2_rsa']
  data = signature[-40:]
  for i in xrange(n1):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  return StrXor(middle, data)


SSH2_AGENTC_REQUEST_IDENTITIES = 11
SSH2_AGENT_IDENTITIES_ANSWER = 12
SSH2_AGENTC_SIGN_REQUEST = 13
SSH2_AGENT_SIGN_RESPONSE = 14
SSH_AGENT_FAILURE = 5


def RecvAll(sock, size):
  if size == 0:
    return ''
  assert size >= 0
  if hasattr(sock, 'recv'):
    recv = sock.recv
  else:
    recv = sock.read
  data = recv(size)
  if len(data) >= size:
    return data
  assert data, 'unexpected EOF'
  output = [data]
  size -= len(data)
  while size > 0:
    output.append(recv(size))
    assert output[-1], 'unexpected EOF'
    size -= len(output[-1])
  return ''.join(output)

def RecvU32(sock):
  return struct.unpack('>L', RecvAll(sock, 4))[0]

def RecvStr(sock):
  return RecvAll(sock, RecvU32(sock))

def AppendStr(ary, data):
  assert isinstance(data, str)
  ary.append(struct.pack('>L', len(data)))
  ary.append(data)


def ReadRsaInfo(encfile, is_plain_ok):
  """Return (signature, fixup, comment, random, public_key_base64) or (None, None, None, None, None)."""
  # TODO(pts): Write a function which updates the fixup= field in the .akeys
  # file, possibly using GetFixup.
  akeys_filename = encfile + '.akeys'
  try:
    f = open(akeys_filename)
  except IOError:
    return None, None, None, None, None
  # List of aitem dictionaries, as parsed from the akeys file.
  aitems = []
  try:
    for line in f.xreadlines():
      line = line.strip()
      if line.startswith('#') or not line:
        continue
      # TODO(pts): Support spaces in the comment section (ssh-keygen
      # supports it).
      items = line.split()
      i = 0
      h = {}
      while i < len(items):
        match = re.match(r'([^\s=]+)=(\S+)\Z', items[i])
        if not match:
          break
        h[match.group(1)] = match.group(2)
        i += 1
      if i != len(items) - 3 or items[i] != 'ssh-rsa':
        continue
      if not is_plain_ok and not (
          h.get('random', '?') != '?' and h.get('fixup', '?') != '?'):
        continue
      comment = items[i + 2]
      public_key_base64 = items[i + 1]
      public_key = base64.b64decode(public_key_base64)
      if h.get('random', '?') == '?':
        h['random'] = os.urandom(40).encode('hex')
      if h.get('fixup', '?') == '?':
        fixup = None
      else:
        assert re.match('[0-9a-fA-F]{80}\Z', h['fixup'])
        fixup = h['fixup'].decode('hex')
      assert re.match('[0-9a-fA-F]{80}\Z', h['random'])
      # Decode the SSH2 public key.
      assert public_key.startswith('\0\0\0\7ssh-rsa\0\0')
      assert len(public_key) >= 15
      public_exponent_size = struct.unpack('>L', public_key[11 : 15])[0]
      assert len(public_key) >= 15 + public_exponent_size
      public_exponent = int(
          public_key[15 : 15 + public_exponent_size].encode('hex'), 16)
      i = 15 + public_exponent_size
      assert len(public_key) >= 4 + i
      modulus_size = struct.unpack('>L', public_key[i : i + 4])[0]
      assert len(public_key) == 4 + i + modulus_size
      modulus = int(
          public_key[4 + i : 4 + i + modulus_size].encode('hex'), 16)
      aitem = {
          'comment': comment,
          'random': h['random'].decode('hex'),
          'fixup': fixup,
          'public_exponent': public_exponent,
          'modulus': modulus,
          'public_key_base64': public_key_base64,
      }
      aitems.append(aitem)
  finally:
    f.close()
  if not aitems:
    print >>sys.stderr, 'warning: no RSA keys recognized in akeys file: %s' % (
        akeys_filename)
    return None, None, None, None, None

  # Connect to ssh-agent.
  if not os.getenv('SSH_AUTH_SOCK', ''):
    print >>sys.stderr, 'warning: no ssh-agent to connect to'
    return None, None, None, None, None
  sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
  try:
    sock.connect(os.getenv('SSH_AUTH_SOCK'))
  except socket.error, e:
    print >>sys.stderr, 'warning: cannot connect to ssh-agent: %s' % e
    return None, None, None, None, None

  # Get list of public keys, and find our key.
  sock.sendall('\0\0\0\1\v') # SSH2_AGENTC_REQUEST_IDENTITIES
  response = RecvStr(sock)
  resf = cStringIO.StringIO(response)
  assert RecvAll(resf, 1) == chr(SSH2_AGENT_IDENTITIES_ANSWER)
  num_keys = RecvU32(resf)
  assert num_keys < 2000  # A quick sanity check.
  assert num_keys, 'no keys have_been added to ssh-agent'
  comments = set(aitem['comment'] for aitem in aitems)
  found_comment = None
  for i in xrange(num_keys):
    key = RecvStr(resf)
    comment = RecvStr(resf)
    if (not key.startswith('\x00\x00\x00\x07ssh-rsa\x00\x00') or
        comment not in comments):
      continue
    keyf = cStringIO.StringIO(key[11:])
    public_exponent = int(RecvStr(keyf).encode('hex'), 16)
    modulus_str = RecvStr(keyf)
    modulus = int(modulus_str.encode('hex'), 16)
    assert '' == keyf.read(1), 'EOF expected in keyf'
    #print (public_exponent, modulus, comment)
    found_fixup = found_random = found_public_key_base64 = None
    for aitem in aitems:
      if (aitem['public_exponent'] == public_exponent and
          aitem['modulus'] == modulus and aitem['comment'] == comment):
        found_fixup = aitem['fixup']
        found_random = aitem['random']
        found_public_key_base64 = aitem['public_key_base64']
        break
    if found_random is None:
      continue
    found_comment = comment  # Find the last match.
  assert '' == resf.read(1), 'EOF expected in resf'
  if found_comment is None:
    print >>sys.stderr, (
        'warning: keys in ssh-agent not matching any key in: %s' %
        akeys_filename)
    return None, None, None, None, None

  # Ask ssh-agent to sign with our key.
  request_output = [chr(SSH2_AGENTC_SIGN_REQUEST)]
  AppendStr(request_output, key)
  AppendStr(request_output, found_random)  # Message to sign.
  request_output.append(struct.pack('>L', 0))  # flags == 0
  full_request_output = []
  AppendStr(full_request_output, ''.join(request_output))
  full_request_str = ''.join(full_request_output)
  sock.sendall(full_request_str)
  response = RecvStr(sock)
  resf = cStringIO.StringIO(response)
  assert RecvAll(resf, 1) == chr(SSH2_AGENT_SIGN_RESPONSE)
  signature = RecvStr(resf)
  assert '' == resf.read(1), 'EOF expected in resf'
  assert signature.startswith('\0\0\0\7ssh-rsa\0\0')
  sigf = cStringIO.StringIO(signature[11:])
  signature = RecvStr(sigf)
  assert len(signature) >= 40  # Much longer, e.g. 256, 512 or 1024 bytes.
  signed_value = int(signature.encode('hex'), 16)
  assert '' == sigf.read(1), 'EOF expected in sigf'
  #print repr(signed_value)  # This is the same for each run with the same
  # input.

  # Verify the signature.
  decoded_value = pow(signed_value, public_exponent, modulus)
  decoded_hex = '%x' % decoded_value
  if len(decoded_hex) & 1:
    decoded_hex = '0' + decoded_hex
  decoded_str = decoded_hex.decode('hex')
  # (1024, 1025) is not good, it means that the wrong key is used (??)
  assert len(decoded_str) == len(modulus_str) - 2, (  # e.g. (255, 257)
      len(decoded_str), len(modulus_str))
  assert re.match(r'\x01\xFF+\Z', decoded_str[:-36]), 'bad padding found'
  expected_sha1_hex = decoded_hex[-40:]
  msg_sha1_hex = sha1(found_random).hexdigest()
  assert expected_sha1_hex == msg_sha1_hex, 'bad signature (SHA1 mismatch)'

  return (signature[:-40], found_fixup, found_comment,
          found_random, found_public_key_base64)


if __name__ == '__main__':
  if (os.getenv('JOENC1_FILE_WORKER', None) is not None and
      len(sys.argv) == 2):
    sys.exit(JoeFileWorker(int(os.getenv('JOENC1_FILE_WORKER')), sys.argv[1]))

  argv = list(sys.argv)

  if len(argv) <= 1 or argv[1] == '--help':
    ShowUsage()
    sys.exit(0)

  do_getfixup = False
  i = 1
  while i < len(argv):
    if argv[i] == '-getfixup':
      del argv[i]
      do_getfixup = True
      continue
    if not argv[i].startswith('-') or argv[i] == '-':
      break
    i += 1
  if i >= len(argv):
    print >>sys.stderr, 'error: encfile not specified'
    ShowUsage()
    sys.exit(1)

  encfile = argv[i]
  encfile_i = i
  try:
    ste = os.stat(encfile)
  except OSError, e:
    print >>sys.stderr, 'error: encfile not found (touch it 1st): %s' % e
    sys.exit(2)
  if not stat.S_ISREG(ste.st_mode):
    print >>sys.stderr, 'error: encfile is not a regular file: %s' % encfile
    sys.exit(2)

  fd = os.open(encfile, os.O_RDONLY)
  header = os.read(fd, 32)
  if header:  # Non-empty file.
    if len(header) < 32 or not header.startswith(HEADER_START):
      print >>sys.stderr, (
          'error: unrecognized joenc1 header %s in file: %s' %
          (header.encode('hex'), encfile))
      sys.exit(8)

  # TODO(pts): Check against EUID.
  if os.access(encfile, os.W_OK):
    rdonly_flag = '--rdonly'  # read-write
  else:
    rdonly_flag = '-rdonly'  # read-only

  if not os.isatty(2):
    print >>sys.stderr, 'error: stderr must be a terminal'
    sys.exit(2)
  st0 = os.fstat(0)
  st1 = os.fstat(1)
  st2 = os.fstat(2)
  # We need this check so we'll be able to distinguish between input and
  # output for joe '!joenc'.
  if ((st0.st_mode & ~07777) != (st1.st_mode & ~07777) or
      st0.st_dev != st1.st_dev):
    print >>sys.stderr, 'error: stdin and stdout are not the same terminals'
    sys.exit(2)
  if ((st0.st_mode & ~07777) != (st2.st_mode & ~07777) or
      st0.st_dev != st2.st_dev):
    print >>sys.stderr, 'error: stdin and stderr are not the same terminals'
    sys.exit(2)
  myprog = os.path.abspath(argv[0])
  assert '\0' not in myprog
  assert myprog.startswith('/')
  if re.match(r'[-:,~@%^={}+@/.\w]+\Z', myprog):
    myprog_quoted = myprog
  else:
    myprog_quoted = "'%s'" % myprog.replace("'", "'\\''")
  try:
    stp = os.stat(myprog)
  except OSError:
    print >>sys.stderr, 'error: my binary not found: %s' % myprog
    sys.exit(2)
  if not stat.S_ISREG(stp.st_mode) or (stp.st_mode & 0100) == 0:
    print >>sys.stderr, 'error: my binary is not executable: %s' % myprog
    sys.exit(2)
  try:
    os.fstat(PASSPHRASE_FD)
    e = None
  except OSError, e:
    if e.errno != errno.EBADF:
      raise
  if not e:
    print >>sys.stderr, 'error: file descriptor used: %d' % PASSPHRASE_FD
    sys.exit(2)

  joe_prog = (FindOnPath('joe-p37') or
              FindOnPath('joe-p35') or
              FindOnPath('joe.mc') or
              FindOnPath('joe'))
  if not joe_prog:
    print >>sys.stderr, 'error: joe: command not found'
    sys.exit(7)

  if header:
    signature, fixup, comment, random, public_key_base64 = ReadRsaInfo(encfile, do_getfixup)
  else:
    signature = fixup = comment = random = public_key_base64 = None

  if signature is None or do_getfixup:
    if not header:
      prompt = 'joenc1 new passphrase of empty %r: ' % encfile
    elif do_getfixup:
      if signature is None:
        print >>sys.stderr, 'error: getfixup without matching signature'
        sys.exit(10)
      prompt = 'joenc1 passphrase for getfixup of %r: ' % encfile
    else:
      prompt = 'joenc1 passphrase of %r: ' % encfile
    try:
      passphrase = getpass.getpass(prompt=prompt)
    except EOFError:
      print >>sys.stderr, 'info: end-of-file, exiting'
      sys.exit(4)
    except KeyboardInterrupt:
      print >>sys.stderr, 'info: interrupted, exiting'
      sys.exit(4)
    passphrase = passphrase.strip()
    if do_getfixup:
      fixup = GetFixup(passphrase, signature)
      # TODO(pts): Emit the whole key line, or update encfile + '.akeys'.
      akeys_line = 'fixup=%s random=%s ssh-rsa %s %s\n' % (
          fixup.encode('hex'), random.encode('hex'),
          public_key_base64, comment)
    passphrasen = PreprocessPassphrase(passphrase)
    if not header:  # Empty file.
      try:
        passphrase_again = getpass.getpass(prompt='Passphrase again: ')
      except EOFError:
        print >>sys.stderr, 'end-of-file, exiting'
        sys.exit(4)
      except KeyboardInterrupt:
        print >>sys.stderr, 'interrupted, exiting'
        sys.exit(4)
      passphrase_again = passphrase_again.strip()
      if passphrase_again != passphrase:
        print >>sys.stderr, 'error: new passphrase mismatch'
        sys.exit(6)
      del passphrase_again
    del passphrase
  else:
    print >>sys.stderr, 'info: using RSA key %s' % comment
    passphrasen = PreprocessRsaSignature(signature, fixup)
  assert '\n' not in passphrasen
  passphrasen += '\n'

  if header:  # Non-empty file.
    # Create passphrase pipe for openssl below.
    pp_read_fd, pp_write_fd = os.pipe()
    if pp_read_fd != PASSPHRASE_FD:
      if pp_write_fd == PASSPHRASE_FD:
        pp_write_fd = os.dup(pp_write_fd)
      os.dup2(pp_read_fd, PASSPHRASE_FD)
      os.close(pp_read_fd)
      pp_read_fd = PASSPHRASE_FD
    # pp_read_fd has ~FD_CLOEXEC by default, we don't have to change that.
    fcntl.fcntl(pp_write_fd, fcntl.F_SETFD,
                fcntl.fcntl(pp_write_fd, fcntl.F_GETFD) | fcntl.FD_CLOEXEC)

    # Start openssl to decrypt the file in order to compute the hmac.
    expected_hmac = header[12 : 32]
    assert len(passphrasen) == os.write(pp_write_fd, passphrasen)
    if fd > 9:  # TODO(pts): Restore this after os.system
      os.dup2(fd, 3)
      os.close(fd)
      fd = 3
    rf = os.popen(
        'openssl enc -aes-256-cbc -salt -d -pass fd:%s <&%d' %
        (PASSPHRASE_FD, fd), 'r')
    rfd = rf.fileno()
    hmac_obj = hmac.new(passphrasen[:-1], None, sha1_module)
    while True:
      data = os.read(rfd, 8192)
      if not data:
        break
      hmac_obj.update(data)
    got_hmac = hmac_obj.digest()
    if expected_hmac != got_hmac:
      # We may also display an OpenSSL error above.
      print >>sys.stderr, 'error: hmac mismatch (bad passphrase?): %s' % (
          encfile)
      sys.exit(9)
    del hmac_obj
    status = rf.close() or 0
    if status:
      # This doesn't always detect the failure, sometimes it just decrypts the
      # wrong data (we'd need file integrity protection).
      print >>sys.stderr, 'error: decryption failed (bad passphrase?)'
      sys.exit((status >> 8) or 5)
  os.close(fd)

  if do_getfixup:
    # TODO(pts): Insert it to the .akeys file automatically.
    sys.stdout.write(akeys_line)
    sys.exit(0)

  # The need-password pipe.
  np_read_fd, np_write_fd = os.pipe()
  fcntl.fcntl(np_read_fd, fcntl.F_SETFD,
              fcntl.fcntl(np_read_fd, fcntl.F_GETFD) | fcntl.FD_CLOEXEC)

  os.environ['JOENC1_FILE_WORKER'] = str(np_write_fd)
  joe_cmd = ([joe_prog] + argv[1 : encfile_i] + [rdonly_flag] +
             ['!%s %s' % (QuoteShellWord(myprog), QuoteShellWord(encfile))] +
             argv[encfile_i + 1:])
  p = subprocess.Popen(joe_cmd)
  # TODO(pts): Solve this without threads.
  thread.start_new_thread(
      ErrorWrapper, (PassphraseSender, np_read_fd, pp_write_fd, passphrasen))
  sys.exit(p.wait())
