#! /usr/bin/env python
# by pts@fazekas.hu at Sun Jun  6 18:06:47 CEST 2010

"""Start joe(1) opening and encrypting a single file. !! fix for non-joe

Example old command:

  joe [-beep] file1 file2 file3

Example new command, with automatic decryption on load and encryption on save.

  $ touch encrypted-file1
  $ joenc1 [-beep] encrypted-file1 file2 file3
  joenc1 new passphrase for 'encrypted-file1':

Example setup for SSH signing:

  # Create encrypted-file1 just as above (pick a passphrase, can be random).
  # Start ssh-agent and make sure you have a working $SSH_AUTH_SOCK .
  # Create your SSH keypair. Make sure it's RSA (-t rsa).
  # Don't put whitespace in the comment below:  !! why no whitespace?
  $ ssh-keygen -t rsa -b 4096 -C 'my-joenc1-key' -f keyfile
  # You may or may not have an SSH key passphrase here.
  $ ssh-add keyfile
  $ cp keyfile.pub encrypted-file1.akey
  $ joenc1 -getfixup encrypted-file1
  # Type encrypted-file1 passphrase.
  # Copy-paste the printed output back to encrypted-file1.
  $ joenc1 encrypted-file1
  # This should not ask for the encrypted-file1 passphrase (but it should
  # for the SSH key passphrase if not added to the agent).
"""

__author__ = 'pts@fazekas.hu (Peter Szabo)'

import base64
import cStringIO
import errno
import fcntl
import getpass
import hmac
import os
import os.path
import re
import socket
import stat
import struct
import subprocess
import sys
import thread
import time
import traceback


class Error(Exception):
  """Common base class for exceptions defined in this module."""


# SHA-1 (160 bit output), available since Python2.4 (or earlier).
try:
  import hashlib  # No deprecation warning in Python 2.6.
  sha1 = hashlib.sha1
except (ImportError, AttributeError):
  from sha import sha as sha1

sha1_module = type(sys)('sha1_module')
sha1_module.new = sha1
sha1_module.digest_size = 20

# Just a quick sanity check.
assert 'c387b401c957209a84d581a23247f9199292a052' == hmac.new(
    'mykey', 'mymsg', sha1_module).hexdigest()
m = hmac.new('mykey', None, sha1_module)
m.update('mymsg')
assert 'c387b401c957209a84d581a23247f9199292a052' == m.hexdigest()


HEADER_START_V1 = '\0J1\x1A.'  # Old file format.
HEADER_START = '\0J1\x1A/'
# The byte '/' denotes the file version, and '56789AB' are unused.
HEADER_IN_PROGRESS = '\0J1\x1A/56789AB((((SHA1CHECKSUM))))'


def PassphraseSender(np_read_fd, pp_write_fd, passphrasen):
  """Waits for a passphrase to be required, sends it infinite loop.

  Timeline of one loop iteration:

  1. Client sends 'W' to np_write_fd.
  2. PassphraseSender receives the 'W' in np_read_fd.
  3. PassphraseSender sends the passphrase + '\n' to pp_write_fd.
  4. Client receives the passphrase + '\n' on passphrase_fd. 
  """
  # Exceptions raised here a lost (not reported to joe).
  if not isinstance(passphrasen, str):
    raise TypeError
  while 1:
    os.read(np_read_fd, 1)
    # Not calling WriteAll, on purpose, to guarantee atomicity.
    got = os.write(pp_write_fd, passphrasen)
    assert got == len(passphrasen)


def ErrorWrapper(function, *args, **kwargs):
  try:
    return function(*args, **kwargs)
  except:
    # TODO(pts): Print the caller as well.
    typ, exc, tb = sys.exc_info()
    traceback.print_exception(typ, exc, tb.tb_next)
    return None


def FdSource(fd):
  while 1:
    data = os.read(fd, 8192)
    if not data:
      break
    yield data


def WriteAll(fd, output):
  """Write an str or buffer to a file descriptor."""
  if not isinstance(output, (str, buffer)):
    raise TypeError
  if output:
    got = os.write(fd, output)
    while got < len(output):
      output = buffer(output, got)
      got = os.write(fd, output)
  #os.write(1, 'READ FILE TO JOE')


def WriteCrypt(encfile, source, passphrase_requester, passphrase_fd):
  """Write encrypted version of source to encfile.

  Returns:
    The number of plaintext bytes written."""
  passphrase_requester()
  passphrasen = os.read(passphrase_fd, 4096)
  i = passphrasen.find('\n')
  assert i == len(passphrasen) - 1
  hmac_obj = hmac.new(passphrasen[:-1], None, sha1_module)
  passphrasen = None  # Don't remember it too long.
  passphrase_requester()
  # TODO(pts): To prevent data loss, create a temporary file, write to it,
  # and move it on success. Also add O_CREAT.
  fd = os.open(encfile, os.O_WRONLY | os.O_TRUNC, 0644)
  size = 0
  try:
    # Write the header.
    assert 32 == os.write(fd, HEADER_IN_PROGRESS)
    p = subprocess.Popen(
        ('openssl', 'enc', '-aes-256-cbc', '-salt', '-pass',
         'fd:%d' % passphrase_fd),
        stdin=subprocess.PIPE, stdout=fd)
    try:
      for data in source:
        size += len(data)
        hmac_obj.update(data)
        p.stdin.write(data)
        p.stdin.flush()
    finally:
      p.stdin.close()
      exit_code = p.wait()
    assert not exit_code, 'openssl encrypt failed with exit_code=%r' % exit_code
    os.lseek(fd, 12, 0)
    assert 20 == os.write(fd, hmac_obj.digest())
    return size
  finally:
    os.close(fd)


class ReadCryptError(Error):
  """Raised on a crypto error when reading an encrypted file."""


class ReadCryptOpensslError(ReadCryptError):
  """Raised when openssl has failed decrypting."""


class ReadCryptHmacError(ReadCryptError):
  """Raised at a HMAC mismatch when decrypting."""


def FdPassphraseRequester(np_write_fd):
  def FdRequest():
    os.write(np_write_fd, 'W')
  
  return FdRequest


def InstantPassphraseRequester(pp_write_fd, passphrasen):
  def InstantRequest():
    # Not calling WriteAll, on purpose, to guarantee atomicity.
    got = os.write(pp_write_fd, passphrasen)
    assert got == len(passphrasen)

  return InstantRequest  


def ReadCrypt(encfile, passphrase_requester, passphrase_fd, need_plaintext):
  """Read and decrypt encfile, return the full plaintext."""
  fd = os.open(encfile, os.O_RDONLY)
  try:
    header = os.read(fd, 32)
    if not header:
      return ''
    if len(header) != 32 or not header.startswith(HEADER_START):
      assert 0, ('error: unrecognized header %s' %
                 header.encode('hex'))
    expected_hmac = header[12 : 32]
    passphrase_requester()
    passphrasen = os.read(passphrase_fd, 4096)
    i = passphrasen.find('\n')
    assert i == len(passphrasen) - 1
    hmac_obj = hmac.new(passphrasen[:-1], None, sha1_module)
    passphrasen = None  # Don't rememer it to olong.
    # Ask the parent to write the passphrase for openssl below.
    passphrase_requester()
    p = subprocess.Popen(
        ('openssl', 'enc', '-aes-256-cbc', '-salt', '-d', '-pass',
         'fd:%d' % passphrase_fd),
        stdin=fd, stdout=subprocess.PIPE)
    try:
      plaintext = []
      while 1:
        data = p.stdout.read(8192)
        if not data:
          break
        hmac_obj.update(data)
        if need_plaintext:
          plaintext.append(data)
    finally:
      exit_code = p.wait()
    got_hmac = hmac_obj.digest()
    if expected_hmac != got_hmac:
      # Don't write anything until hmac is proven correct.
      # We may also display an OpenSSL error above.
      raise ReadCryptHmacError
    if exit_code:
      raise ReadCryptOpensslError(
          'openssl decrypt failed with exit_code=%r' % exit_code)
    return ''.join(plaintext)
  finally:
    os.close(fd)


def JoeFileWorker(np_write_fd, passphrase_fd, encfile):
  """Called when this program was invoked by joe through `!file'."""
  tty_fd = os.open('/dev/tty', os.O_WRONLY)
  if tty_fd != 2:
    os.dup2(tty_fd, 2)
    os.close(tty_fd)
  passphrase_requester = FdPassphraseRequester(np_write_fd)
  try:
    st0 = os.fstat(0)
    st1 = os.fstat(1)
    if stat.S_ISFIFO(st1.st_mode) and not stat.S_ISFIFO(st0.st_mode):
      WriteAll(1, ReadCrypt(encfile, passphrase_requester, passphrase_fd, True))
    elif stat.S_ISFIFO(st0.st_mode) and not stat.S_ISFIFO(st1.st_mode):
      # TODO(pts): Better write error handling.
      #open('save.dat', 'w').write(time.ctime() + '\n' + sys.stdin.read())
      WriteCrypt(encfile, FdSource(0), passphrase_requester, passphrase_fd)
      # TODO(pts): Better error reporting on assertion failure here.
    else:
      assert 0, 'error: invalid pipe invocation'
  except SystemExit:
    pass
  except:
    typ, exc, tb = sys.exc_info()
    os.close(1)
    if not os.fork():  # Report in a child process, so joe doesn't wait for it.
      time.sleep(0.3)
      if isinstance(exc, AssertionError):
        os.write(2, 'joenc1 ERROR: %s\r' % exc)
      else:
        os.write(2, 'joenc1 EXC: %s: %s\r' % (type(exc).__name__, exc))
      traceback.print_exc()
      os._exit(3)


def ShowUsage():
  # !! show more
  print >>sys.stderr, (
      'Usage: %s [<joe-flag> ...] <encfile> [<file> ...]' % sys.argv[0])


def QuoteShellWord(word):
  """Quote a word from /bin/sh (Bourne shell)."""
  if re.match(r'[-:,@%=+/.\w][-:,~@%^={}+/.\w]*\Z', word):
    return word
  else:
    return "'%s'" % word.replace("'", "'\\''")


def FindOnPath(binary):
  if '/' in binary:
    return binary
  for dir_name in os.getenv('PATH', '/bin:/usr/bin').split(':'):
    if dir_name:
      file_name = os.path.join(dir_name, binary)
      if os.path.isfile(file_name):
        return file_name
  return None

PREP = {
    'salt1': 'foo',
    'salt2': 'bar',
    'num_iterations': 1903,
    'salt1_rsa': 'baz',
    'salt2_rsa': 'quux',
    'num_iterations_before_rsa_fix': 951,
}
"""Parameters of preprocessing."""


def PreprocessPassphrase(passphrase):
  salt1 = PREP['salt1']
  salt2 = PREP['salt2']
  data = passphrase
  for i in xrange(PREP['num_iterations']):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  assert len(data) == 40
  return data.encode('base64').rstrip('\n')


def StrXor(s1, s2):
  # PyCrypto has a faster implementation (but Python 2.6 doesn't), but we don't care much here, because
  # we don't call StrXor in an inner loop.
  return ''.join(map(lambda x, y: chr(ord(x) ^ ord(y)), s1, s2))


def PreprocessRsaSignature(signature, fixup):
  assert len(fixup) == 40
  assert len(signature) >= 40
  salt1 = PREP['salt1_rsa']
  salt2 = PREP['salt2_rsa']
  data = signature[-40:]  # TODO(pts): Don't we want the whole signature?
  n1 = PREP['num_iterations_before_rsa_fix']
  n2 = PREP['num_iterations']
  # It would work (but may be cryptographically weaker with <= instead of <).
  assert 0 < n1 < n2
  for i in xrange(n1):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  assert len(data) == 40
  data = StrXor(data, fixup)
  salt1 = PREP['salt1']
  salt2 = PREP['salt2']
  for i in xrange(n1, n2):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  # 40 bytes before base64, 56 bytes after.
  return data.encode('base64').rstrip('\n')


def GetFixup(passphrase, signature):
  """Compute and return the binary fixup= value for the .akeys file."""
  assert len(signature) >= 40
  n1 = PREP['num_iterations_before_rsa_fix']
  salt1 = PREP['salt1']
  salt2 = PREP['salt2']
  data = passphrase
  for i in xrange(n1):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  middle = data
  salt1 = PREP['salt1_rsa']
  salt2 = PREP['salt2_rsa']
  data = signature[-40:]
  for i in xrange(n1):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  return StrXor(middle, data)


SSH2_AGENTC_REQUEST_IDENTITIES = 11
SSH2_AGENT_IDENTITIES_ANSWER = 12
SSH2_AGENTC_SIGN_REQUEST = 13
SSH2_AGENT_SIGN_RESPONSE = 14
SSH_AGENT_FAILURE = 5


def RecvAll(sock, size):
  if size == 0:
    return ''
  assert size >= 0
  if hasattr(sock, 'recv'):
    recv = sock.recv
  else:
    recv = sock.read
  data = recv(size)
  if len(data) >= size:
    return data
  assert data, 'unexpected EOF'
  output = [data]
  size -= len(data)
  while size > 0:
    output.append(recv(size))
    assert output[-1], 'unexpected EOF'
    size -= len(output[-1])
  return ''.join(output)


def RecvU32(sock):
  return struct.unpack('>L', RecvAll(sock, 4))[0]


def RecvStr(sock):
  return RecvAll(sock, RecvU32(sock))


def AppendStr(ary, data):
  assert isinstance(data, str)
  ary.append(struct.pack('>L', len(data)))
  ary.append(data)


def YieldSshAgentRsaKeys(sock=None):
  if sock is None:
    if os.getenv('SSH_AUTH_SOCK', ''):
      sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
    try:
      sock.connect(os.getenv('SSH_AUTH_SOCK'))
    except socket.error, e:
      sock = None
  if sock is not None:  # Silently ignore sock is None.
    sock.sendall('\0\0\0\1\v') # SSH2_AGENTC_REQUEST_IDENTITIES
    response = RecvStr(sock)
    resf = cStringIO.StringIO(response)
    assert RecvAll(resf, 1) == chr(SSH2_AGENT_IDENTITIES_ANSWER)
    num_keys = RecvU32(resf)
    assert num_keys < 2000  # A quick sanity check.
    # TODO(pts): Make this work again.
    #if not num_keys:
    #  print >>sys.stderr, 'warning: no keys have_been added to ssh-agent'
    #  return None, None, None, None
    # Please note that the SSH agent in Ubuntu Lucid doesn't store the
    # original SSH key comment, but it stores the absolute local filename of
    # the private key.
    for i in xrange(num_keys):
      key = RecvStr(resf)
      comment_or_filename = RecvStr(resf)
      if not key.startswith('\x00\x00\x00\x07ssh-rsa\x00\x00'):
        continue
      keyf = cStringIO.StringIO(key[11:])
      public_exponent = int(RecvStr(keyf).encode('hex'), 16)
      modulus_str = RecvStr(keyf)
      modulus = int(modulus_str.encode('hex'), 16)
      assert '' == keyf.read(1), 'EOF expected in keyf'
      yield public_exponent, modulus, comment_or_filename, key
    assert '' == resf.read(1), 'EOF expected in resf'
  # TODO(pts): Do an explicit sock.close if we've just opened it.


def ParseRsaPublicKey(line):
  """Parses an RSA key from a line in ~/.ssh/id_*.pub or authorized_keys.

  Returns:
    A dict describing the results or None if key not found.
  """
  line = line.strip()
  if line.startswith('#') or not line:
    return None
  # !! TODO(pts): Support spaces in the comment section (ssh-keygen
  # supports it).
  items = line.split()
  i = 0
  h = {}
  while i < len(items):
    match = re.match(r'([^\s=]+)=("([^"]*)"|\S+)\Z', items[i])
    if not match:
      break
    if match.group(3) is not None:
      h[match.group(1)] = match.group(3)
    else:
      h[match.group(1)] = match.group(2)
    i += 1
  if i != len(items) - 3 or items[i] != 'ssh-rsa':
    return None
  comment = items[i + 2]
  public_key_base64 = items[i + 1]
  public_key = base64.b64decode(public_key_base64)
  # Now public_key_base64 is the base64-encoded version of the public
  # key, i.e. the long word starting with AAAA... after 'ssh-rsa ' in
  # ~/.ssh/id_*.pub and ~/.ssh/authorized_keys.
  if h.get('random', '?') == '?':
    random = None
  else:
    assert re.match('[0-9a-fA-F]{80}\Z', h['random'])
    random = h['random'].decode('hex')
  if h.get('fixup', '?') == '?':
    fixup = None
  else:
    assert re.match('[0-9a-fA-F]{80}\Z', h['fixup'])
    fixup = h['fixup'].decode('hex')
  # Decode the SSH2 RSA public key.
  assert public_key.startswith('\0\0\0\7ssh-rsa\0\0')
  assert len(public_key) >= 15
  public_exponent_size = struct.unpack('>L', public_key[11 : 15])[0]
  assert len(public_key) >= 15 + public_exponent_size
  public_exponent = int(
      public_key[15 : 15 + public_exponent_size].encode('hex'), 16)
  i = 15 + public_exponent_size
  assert len(public_key) >= 4 + i
  modulus_size = struct.unpack('>L', public_key[i : i + 4])[0]
  assert len(public_key) == 4 + i + modulus_size
  modulus = int(
      public_key[4 + i : 4 + i + modulus_size].encode('hex'), 16)
  return {  # aitem.
      'comment': comment,
      'random': random,
      'fixup': fixup,
      'public_exponent': public_exponent,
      'modulus': modulus,
      'public_key_base64': public_key_base64,
  }


def ReadRsaInfo(encfile, is_plain_ok):
  """Return (signature, fixup, random, public_key_base64) or (None, None, None, None)."""
  # TODO(pts): Write a function which updates the fixup= field in the .akeys
  # file, possibly using GetFixup.
  akeys_filename = encfile + '.akeys'
  try:
    f = open(akeys_filename)
  except IOError:
    return None, None, None, None
  # List of aitem dictionaries, as parsed from the akeys file.
  aitems = []
  try:
    for line in f.xreadlines():
      aitem = ParseRsaPublicKey(line)
      if aitem is None:
        continue
      if is_plain_ok:
        if aitem['random'] is None:
          aitem['random'] = os.urandom(40)  # TODO(pts): Move it later.
      else:
        if aitem['random'] is None or aitem['fixup'] is None:
          continue
      aitems.append(aitem)
  finally:
    f.close()
  if not aitems:
    print >>sys.stderr, 'warning: no RSA keys recognized in akeys file: %s' % (
        akeys_filename)
    return None, None, None, None

  # Connect to ssh-agent.
  if not os.getenv('SSH_AUTH_SOCK', ''):
    print >>sys.stderr, 'warning: no ssh-agent to connect to'
    return None, None, None, None
  sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
  try:
    sock.connect(os.getenv('SSH_AUTH_SOCK'))
  except socket.error, e:
    print >>sys.stderr, 'warning: cannot connect to ssh-agent: %s' % e
    return None, None, None, None

  # Get list of public keys, and find our key.
  #
  # Please note that the SSH agent in Ubuntu Lucid doesn't store the
  # original SSH key comment, but it stores the absolute local filename of
  # the private key. So we just ignore comments.
  is_found = False
  for public_exponent, modulus, unused_comment_or_filename, key in (
      YieldSshAgentRsaKeys(sock)):
    for aitem in aitems:
      if (aitem['public_exponent'] == public_exponent and
          aitem['modulus'] == modulus):
        #assert not is_found, 'Found multiple matching keys in ssh-agent.'
        is_found = True
        found_key = key
        found_fixup = aitem['fixup']
        found_random = aitem['random']
        found_public_key_base64 = aitem['public_key_base64']
        break
  if not is_found:
    print >>sys.stderr, (
        'warning: keys in ssh-agent not matching any key in: %s' %
        akeys_filename)
    return None, None, None, None

  # Ask ssh-agent to sign with our key.
  # TODO(pts): What happens after reboot, with Ubuntu Lucid's GNOME's
  # ssh-agent? It fakes that it has the key added, but it can't encrypt
  # properly with it. Sigh. But maybe another key has been already added
  # properly.
  request_output = [chr(SSH2_AGENTC_SIGN_REQUEST)]
  AppendStr(request_output, found_key)
  AppendStr(request_output, found_random)  # Message to sign.
  request_output.append(struct.pack('>L', 0))  # flags == 0
  full_request_output = []
  # TODO(pts): Do this without copying.
  AppendStr(full_request_output, ''.join(request_output))
  full_request_str = ''.join(full_request_output)
  sock.sendall(full_request_str)
  response = RecvStr(sock)
  resf = cStringIO.StringIO(response)
  assert RecvAll(resf, 1) == chr(SSH2_AGENT_SIGN_RESPONSE)
  signature = RecvStr(resf)
  assert '' == resf.read(1), 'EOF expected in resf'
  assert signature.startswith('\0\0\0\7ssh-rsa\0\0'), repr(signature[:16])
  sigf = cStringIO.StringIO(signature[11:])
  signature = RecvStr(sigf)
  assert len(signature) >= 40  # Much longer, e.g. 256, 512 or 1024 bytes.
  signed_value = int(signature.encode('hex'), 16)
  assert '' == sigf.read(1), 'EOF expected in sigf'
  #print repr(signed_value)  # This is the same for each run with the same
  # input.

  # Verify the signature.
  decoded_value = pow(signed_value, public_exponent, modulus)
  decoded_hex = '%x' % decoded_value
  if len(decoded_hex) & 1:
    decoded_hex = '0' + decoded_hex
  decoded_str = decoded_hex.decode('hex')

  # (1024, 1025) is not good, it means that the wrong key is used (??)
  #modulus_str = RecvStr(keyf)
  #modulus = int(modulus_str.encode('hex'), 16)
  modulus_str = '00%x' % modulus
  if len(modulus_str) % 2 == 1:
    modulus_str = '0' + modulus_str
  modulus_str = modulus_str.decode('hex')
  assert len(decoded_str) == len(modulus_str) - 2, (  # e.g. (255, 257)
      len(decoded_str), len(modulus_str))

  assert re.match(r'\x01\xFF+\Z', decoded_str[:-36]), 'bad padding found'
  expected_sha1_hex = decoded_hex[-40:]
  msg_sha1_hex = sha1(found_random).hexdigest()
  assert expected_sha1_hex == msg_sha1_hex, 'bad signature (SHA1 mismatch)'

  return (signature[:-40], found_fixup,
          found_random, found_public_key_base64)


def FindJoeBinaryPath():
  """Finds the joe binary on $PATH and returns the pathname, or None."""
  return (FindOnPath('joe-p37') or
          FindOnPath('joe-p35') or
          FindOnPath('joe.mc') or
          FindOnPath('joe'))


def GetMyBinaryPath(argv0):
  """Figure out and return the full path to this joenc1 binary."""
  myprog = os.path.abspath(argv0)
  assert '\0' not in myprog, repr(myprog)
  assert myprog.startswith('/'), repr(myprog)
  try:
    stp = os.stat(myprog)
  except OSError:
    print >>sys.stderr, 'error: my binary not found: %s' % myprog
    sys.exit(2)
  if not stat.S_ISREG(stp.st_mode) or (stp.st_mode & 0100) == 0:
    print >>sys.stderr, 'error: my binary is not executable: %s' % myprog
    sys.exit(2)
  return myprog


def CheckTerminals():
  """Check that stdin, stdout, stderr filehandles are good terminal devices."""
  if not os.isatty(2):
    print >>sys.stderr, 'error: stderr must be a terminal'
    sys.exit(2)
  st0 = os.fstat(0)
  st1 = os.fstat(1)
  st2 = os.fstat(2)
  # We need this check so we'll be able to distinguish between input and
  # output for joe '!joenc'.
  if ((st0.st_mode & ~07777) != (st1.st_mode & ~07777) or
      st0.st_dev != st1.st_dev):
    print >>sys.stderr, 'error: stdin and stdout are not the same terminals'
    sys.exit(2)
  if ((st0.st_mode & ~07777) != (st2.st_mode & ~07777) or
      st0.st_dev != st2.st_dev):
    print >>sys.stderr, 'error: stdin and stderr are not the same terminals'
    sys.exit(2)


def RunJoe(argv, encfile_i, encfile, pp_write_fd, passphrase_fd, passphrasen,
           joe_prog):
  """Runs joe, does not return (calls sys.exit)."""
  # TODO(pts): Check against EUID.
  if os.access(encfile, os.W_OK):
    rdonly_flag = '--rdonly'  # read-write
  else:
    rdonly_flag = '-rdonly'  # read-only

  myprog = GetMyBinaryPath(argv[0])  # Can fail.
  joe_cmd = list(argv)
  joe_cmd[0] = joe_prog
  joe_cmd[encfile_i] = '!%s %s' % (
      QuoteShellWord(myprog), QuoteShellWord(encfile))
  joe_cmd[encfile_i + 1 : encfile_i + 1] = [rdonly_flag]

  # The need-password pipe.
  np_read_fd, np_write_fd = os.pipe()
  fcntl.fcntl(np_read_fd, fcntl.F_SETFD,
              fcntl.fcntl(np_read_fd, fcntl.F_GETFD) | fcntl.FD_CLOEXEC)
  os.environ['JOENC1_FILE_WORKER'] = '%d:%d' % (np_write_fd, passphrase_fd)

  p = subprocess.Popen(joe_cmd)
  # TODO(pts): Solve this without threads.
  thread.start_new_thread(
      ErrorWrapper, (PassphraseSender, np_read_fd, pp_write_fd, passphrasen))
  sys.exit(p.wait())


def main(argv):
  if (os.getenv('JOENC1_FILE_WORKER', None) is not None and
      len(sys.argv) == 2):
    np_write_fd, passphrase_fd = map(
        int, os.getenv('JOENC1_FILE_WORKER').split(':', 1))
    sys.exit(JoeFileWorker(np_write_fd, passphrase_fd, sys.argv[1]))

  argv = list(argv)

  if len(argv) <= 1 or argv[1] == '--help':
    ShowUsage()
    sys.exit(0)

  do_run_joe = None
  do_getfixup = False
  do_create = False  # Do create if doesn't exist, don't start joe.
  do_encrypt = False
  do_decrypt = False
  do_create_with_key = False
  key_to_add = None
  i = 1
  while i < len(argv):
    arg = argv[i]
    if arg in ('-getfixup', '--getfixup'):
      do_getfixup = True
    elif arg in ('-create', '--create'):
      do_create = True
    elif arg in ('-encrypt', '--encrypt'):
      do_encrypt = True
    elif arg in ('-decrypt', '--decrypt'):
      do_decrypt = True
    elif arg in ('-create-with-key', '--create-with-key') and i + 1 < len(argv):
      do_create_with_key = True
      i += 1
      key_to_add = argv[i]
    elif arg == '--':
      i += 1
      break
    elif not arg.startswith('-') or arg == '-':
      break
    i += 1
  if i >= len(argv):
    print >>sys.stderr, 'error: encfile not specified'
    ShowUsage()
    sys.exit(1)
  dosum = do_create + do_getfixup + do_encrypt + do_decrypt + do_create_with_key
  if do_run_joe is None:
    do_run_joe = not dosum
  if do_run_joe + dosum != 1:
    print >>sys.stder, 'error: invalid combination of action flags'
    ShowUsage()
    sys.exit(1)
  if do_create_with_key:
    do_create = True
  #if key_to_add is not None:

  encfile = argv[i]
  encfile_i = i
  is_new = False
  try:
    ste = os.stat(encfile)
  except OSError, e:
    if e[0] == errno.ENOENT and do_create:
      fd = os.open(encfile, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0644)
      try:
        ste = os.fstat(fd)
      finally:
        os.close(fd)
      is_new = True
    else:
      if e[0] == errno.ENOENT:
        e = encfile
      print >>sys.stderr, 'error: encfile not found (touch it 1st): %s' % e
      sys.exit(2)
  if not stat.S_ISREG(ste.st_mode):
    print >>sys.stderr, 'error: encfile is not a regular file: %s' % encfile
    sys.exit(2)

  fd = os.open(encfile, os.O_RDONLY)
  try:
    header = os.read(fd, 32)
  finally:
    os.close(fd)
  if header:  # Non-empty file.
    if len(header) != 32 or not header.startswith(HEADER_START):
      print >>sys.stderr, (
          'error: unrecognized joenc1 header %s in file: %s' %
          (header.encode('hex'), encfile))
      sys.exit(8)
    if header == HEADER_IN_PROGRESS:
      # TODO(pts): Make sure this can't happen, do autorecovery.
      print >>sys.stderr, (
          'error: previous joenc1 died while saving: %s' %
          (header.encode('hex'), encfile))
      sys.exit(8)

  signature = fixup = random = public_key_base64 = None
  if key_to_add is not None:
    f = open(key_to_add)
    try:
      data = f.read()
    finally:
      f.close()
    if data.startswith('-----BEGIN ') and not key_to_add.endswith('.pub'):
      # Found an SSH2 private key.
      key_to_add += '.pub'
      f = open(key_to_add)
      try:
        data = f.read()
      finally:
        f.close()
    aitems = filter(None, map(ParseRsaPublicKey, data.split('\n')))
    if not aitems:
      print >>sys.stderr, 'error: SSH2 RSA public key not found in: %s' % (
          key_to_add)
      sys.exit(11)
    if len(aitems) > 1:
      print >>sys.stderr, (
          'error: multiple SSH2 RSA public keys found in: %s' % key_to_add)
      sys.exit(11)
    is_found = False
    for public_exponent, modulus, unused_comment_or_filename, unused_key in (
        YieldSshAgentRsaKeys()):
      if (public_exponent == aitems[0]['public_exponent'] and
          modulus == aitems[0]['modulus']):
        is_found = True
    if not is_found:
      print >>sys.stderr, 'info: Adding key to ssh-agent.'
      assert key_to_add.endswith('.pub'), repr(key_to_add)
      private_key_fn = key_to_add[:-4]  # Remove trailing '.pub'.
      exit_code = subprocess.call(('ssh-add', '--', private_key_fn))
      if exit_code:
        print >>sys.stderr, 'error: ssh-add failed: exit_code=%d' % exit_code
        sys.exit(12)
    # !! what if .akeys already contains some valid keys and header is not empty?
    # Use the existing keys to add the new key.
    if not header:  # !!
      print >>sys.stderr, 'info: extending key file: %s.akeys' % encfile
      # 88 printable bytes, without a newline.
      passphrase = os.urandom(66).encode('base64').replace('\n', '')
      akeys_line1 = 'ssh-rsa %s %s\n' % (
          aitems[0]['public_key_base64'], aitems[0]['comment'])
      open(encfile + '.akeys', 'w').write(akeys_line1)  # !! append
      # TODO(pts): Keep other fields in key_to_add.
      signature, fixup, random, public_key_base64 = ReadRsaInfo(
          encfile, True)
      assert signature is not None  # !! better report
      assert fixup is None
      fixup = GetFixup(passphrase, signature)
      del passphrase
      akeys_line = 'fixup=%s random=%s ssh-rsa %s %s\n' % (
          fixup.encode('hex'), random.encode('hex'),
          aitems[0]['public_key_base64'], aitems[0]['comment'])
      open(encfile + '.akeys', 'w').write(akeys_line)  # !! append

  if do_run_joe:
    CheckTerminals()
    joe_prog = FindJoeBinaryPath()
    if not joe_prog:
      print >>sys.stderr, 'error: joe: command not found'
      sys.exit(7)

  if signature is None and header:
    signature, fixup, random, public_key_base64 = ReadRsaInfo(
        encfile, do_getfixup)

  if signature is None or do_getfixup:
    # !! Add flag to prevent the passphrase prompt.
    if not header:
      if is_new:
        prompt = 'joenc1 new passphrase of new %r: ' % encfile
      else:
        prompt = 'joenc1 new passphrase of empty %r: ' % encfile
    elif do_getfixup:
      if signature is None:
        print >>sys.stderr, 'error: getfixup without matching signature'
        sys.exit(10)
      prompt = 'joenc1 passphrase for getfixup of %r: ' % encfile
    else:
      prompt = 'joenc1 passphrase of %r: ' % encfile
    try:
      passphrase = getpass.getpass(prompt=prompt)
    except EOFError:
      print >>sys.stderr, 'info: end-of-file, exiting'
      sys.exit(4)
    except KeyboardInterrupt:
      print >>sys.stderr, 'info: interrupted, exiting'
      sys.exit(4)
    passphrase = passphrase.strip()
    # !! reject empty passphrase
    if do_getfixup:
      fixup = GetFixup(passphrase, signature)
      # !! TODO(pts): Emit the comment part of the key etc.
      akeys_line = 'fixup=%s random=%s ssh-rsa %s %s\n' % (
          fixup.encode('hex'), random.encode('hex'),
          public_key_base64, '-')
    passphrasen = PreprocessPassphrase(passphrase)
    if not header:  # Empty file.
      try:
        passphrase_again = getpass.getpass(prompt='Passphrase again: ')
      except EOFError:
        print >>sys.stderr, 'end-of-file, exiting'
        sys.exit(4)
      except KeyboardInterrupt:
        print >>sys.stderr, 'interrupted, exiting'
        sys.exit(4)
      passphrase_again = passphrase_again.strip()
      if passphrase_again != passphrase:
        print >>sys.stderr, 'error: new passphrase mismatch'
        sys.exit(6)
      del passphrase_again
    del passphrase
  else:
    if not do_decrypt:
      print >>sys.stderr, 'info: using RSA key'
    passphrasen = PreprocessRsaSignature(signature, fixup)
  assert '\n' not in passphrasen
  passphrasen += '\n'

  # Create passphrase pipe for openssl below.
  passphrase_fd, pp_write_fd = os.pipe()
  # passphrase_fd has ~FD_CLOEXEC by default, we don't have to change that.
  fcntl.fcntl(pp_write_fd, fcntl.F_SETFD,
              fcntl.fcntl(pp_write_fd, fcntl.F_GETFD) | fcntl.FD_CLOEXEC)
  passphrase_requester = InstantPassphraseRequester(pp_write_fd, passphrasen)

  if not header and (do_create or do_run_joe):
    WriteCrypt(encfile, (), passphrase_requester, passphrase_fd)
    print >>sys.stderr, 'info: created with empty plaintext: %s' % encfile

  try:
    if do_decrypt:
      # Don't write anything until verified.
      plaintext = ReadCrypt(encfile, passphrase_requester, passphrase_fd, True)
      WriteAll(1, plaintext)
    else:
      ReadCrypt(encfile, passphrase_requester, passphrase_fd, False)
  except ReadCryptHmacError:
    # This doesn't always detect the failure, sometimes it just decrypts the
    # wrong data, that's why we have integrity protection with the hmac above.
    print >>sys.stderr, 'error: decryption failed (bad passphrase?)'
    sys.exit(5)
  except ReadCryptOpensslError:
    # In addition to this error, the `openssl' command may also display a
    # decryption error above. But it doesn't always do so.
    print >>sys.stderr, 'error: hmac mismatch (bad passphrase?): %s' % (
        encfile)
    sys.exit(9)

  if do_run_joe:
    RunJoe(argv, encfile_i, encfile, pp_write_fd, passphrase_fd, passphrasen,
           joe_prog)
  elif do_getfixup:
    # !! TODO(pts): Emit the whole key line, or update encfile + '.akeys'.
    # TODO(pts): Insert it to the .akeys file automatically.
    sys.stdout.write(akeys_line)
  elif do_create:
    if header:
      print >>sys.stderr, 'info: encfile verified OK, kept intact: %s' % encfile
  elif do_encrypt:
    size = WriteCrypt(encfile, FdSource(0), passphrase_requester, passphrase_fd)
    print >>sys.stderr, 'info: encrypted %d plaintext bytes to: %s' % (
        size, encfile)
    
  # TODO(pts): Close pp_write_fd etc.


if __name__ == '__main__':
  sys.exit(main(sys.argv))
