#! /bin/sh
# by pts@fazekas.hu at Sun Jun  6 18:06:47 CEST 2010

""":" #joenc1: Convenient single-file encryption with passphrases and SSH keys.

type python2.7 >/dev/null 2>&1 && exec python2.7 -- "$0" ${1+"$@"}
type python2.6 >/dev/null 2>&1 && exec python2.6 -- "$0" ${1+"$@"}
type python2.5 >/dev/null 2>&1 && exec python2.5 -- "$0" ${1+"$@"}
type python2.4 >/dev/null 2>&1 && exec python2.4 -- "$0" ${1+"$@"}
exec python -- ${1+"$@"}; exit 1

Requirements: Python (2.4, 2.5, 2.6 or 2.7; doesn't work with 3.x) and the
openssl(1) command-line tool. For SSH keys, a running ssh-agent is also
needed. For JOE text editor intergration, the joe binary is also needed.

Typical first steps using a passphrase:

  $ joenc1 --create encrypted-file1  # Prompts for the new passphrase.
  $ echo hello | joenc1 --encrypt encrypted-file1
  $ joenc1 --decrypt encrypted-file1

Typical first steps using SSH keys:

  $ ssh-add -L  # Just to make sure ssh-agent is running fine.
  $ ssh-keygen -t rsa -b 4096 -C my-joenc1-key -f ssh-keyfile
  # If you don't want to have a key passphrase, just press Enter above.
  $ joenc1 --create-with-key ssh-keyfile encrypted-file2
  # joenc1 calls `ssh-add ssh-keyfile' automatically.
  $ echo hello | joenc1 --encrypt encrypted-file2
  $ joenc1 --decrypt encrypted-file2

Typical command-line usage:

  $ joenc1 --create encrypted-file1
  $ joenc1 --create-with-key ssh-keyfile encrypted-file1
  $ joenc1 --decrypt encrypted-file1  # Writes plaintext to stdout on success.
  $ joenc1 --encrypt encrypted-file1  # Reads plaintext from stdin.

Typical startup of the JOE text editor for editing encrypted text files:

  # Instead of: $ joe [-flag...] file1 file2 file3
  $ joenc1 [-flag...] encrypted-file1 file2 file3

Setup notes:

* Use the --create flag to create an empty encrypted file with a passphrase.
* Calling --create again is a no-op (it won't clobber the file).
* You can add SSH keys later using --create-with-key. An SSH key available in
  the ssh-agent can be used instead of a passphrase.
* If you create the encrypted file with --create-with-key, then no passphrase
  would ever be asked, and the only way to decrypt the file is using SSH keys
  (added to the ssh-agent).
* You can add subsequent SSH keys later using --create-with-key. This won't
  clobber the file, and it won't remove existing SSH keys.
* Any SSH key added with --create-with-key will work for encryption and
  decryption.
* The added SSH keys are stored in encrypted-file1.akeys.
* Only SSH2 RSA keys are supported.
"""

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

__author__ = 'pts@fazekas.hu (Peter Szabo)'

import base64
import cStringIO
import errno
import fcntl
import getpass
import hmac
import os
import os.path
import re
import socket
import stat
import struct
import subprocess
import sys
import thread
import time
import traceback


class Error(Exception):
  """Common base class for exceptions defined in this module."""


# SHA-1 (160 bit output), available since Python2.4 (or earlier).
try:
  import hashlib  # No deprecation warning in Python 2.6.
  sha1 = hashlib.sha1
except (ImportError, AttributeError):
  from sha import sha as sha1

sha1_module = type(sys)('sha1_module')
sha1_module.new = sha1
sha1_module.digest_size = 20

# Just a quick sanity check.
assert 'c387b401c957209a84d581a23247f9199292a052' == hmac.new(
    'mykey', 'mymsg', sha1_module).hexdigest()
m = hmac.new('mykey', None, sha1_module)
m.update('mymsg')
assert 'c387b401c957209a84d581a23247f9199292a052' == m.hexdigest()


HEADER_START_V1 = '\0J1\x1A.'  # Old file format.
HEADER_START_NOSSHONLY = '\0J1\x1A/'
HEADER_START_SSHONLY = '\0J1\x1A-'
# The byte '/' denotes the file version, and '56789AB' are unused.
HEADER_IN_PROGRESS = '\0J1\x1A,56789AB((((SHA1CHECKSUM))))'


def PassphraseSender(np_read_fd, pp_write_fd, passphrasen):
  """Waits for a passphrase to be required, sends it infinite loop.

  Timeline of one loop iteration:

  1. Client sends 'W' to np_write_fd.
  2. PassphraseSender receives the 'W' in np_read_fd.
  3. PassphraseSender sends the passphrase + '\n' to pp_write_fd.
  4. Client receives the passphrase + '\n' on passphrase_fd.
  """
  # Exceptions raised here a lost (not reported to joe).
  if not isinstance(passphrasen, str):
    raise TypeError
  while 1:
    os.read(np_read_fd, 1)
    # Not calling WriteAll, on purpose, to guarantee atomicity.
    got = os.write(pp_write_fd, passphrasen)
    assert got == len(passphrasen)


def ErrorWrapper(function, *args, **kwargs):
  try:
    return function(*args, **kwargs)
  except:
    # TODO(pts): Print the caller as well.
    typ, exc, tb = sys.exc_info()
    traceback.print_exception(typ, exc, tb.tb_next)
    return None


def FdSource(fd):
  while 1:
    data = os.read(fd, 8192)
    if not data:
      break
    yield data


def WriteAll(fd, output):
  """Write an str or buffer to a file descriptor."""
  if not isinstance(output, (str, buffer)):
    raise TypeError
  if output:
    got = os.write(fd, output)
    while got < len(output):
      output = buffer(output, got)
      got = os.write(fd, output)
  #os.write(1, 'READ FILE TO JOE')


def Encrypt(encfile_or_fd, source, passphrase_requester, passphrase_fd,
            is_ssh_only):
  """Write encrypted version of source to encfile.

  Returns:
    The number of plaintext bytes written.
  """
  passphrase_requester()
  passphrasen = os.read(passphrase_fd, 4096)
  i = passphrasen.find('\n')
  assert i == len(passphrasen) - 1
  hmac_obj = hmac.new(passphrasen[:-1], None, sha1_module)
  passphrasen = None  # Don't remember it too long.
  passphrase_requester()
  # TODO(pts): To prevent data loss, create a temporary file, write to it,
  # and move it on success. Also add O_CREAT.
  if isinstance(encfile_or_fd, int):
    fd = encfile_or_fd
  else:
    fd = os.open(encfile, os.O_WRONLY | os.O_TRUNC, 0644)
  size = 0
  try:
    # Write the header.
    assert 32 == os.write(fd, HEADER_IN_PROGRESS)
    # `-md sha1' is better than `-md md5', but the latter is used explicitly
    # for decrypting files created by older versions of openssl.
    p = subprocess.Popen(
        ('openssl', 'enc', '-aes-256-cbc', '-salt', '-md', 'md5',
         '-pass', 'fd:%d' % passphrase_fd),
        stdin=subprocess.PIPE, stdout=fd)
    try:
      for data in source:
        size += len(data)
        hmac_obj.update(data)
        p.stdin.write(data)
        p.stdin.flush()
    finally:
      p.stdin.close()
      exit_code = p.wait()
    assert not exit_code, (
        'openssl encrypt failed with exit_code=%r' % exit_code)
    if is_ssh_only:
      header = HEADER_START_SSHONLY
    else:
      header = HEADER_START_NOSSHONLY
    header += HEADER_IN_PROGRESS[len(header) : 12]
    header += hmac_obj.digest()
    assert len(header) == 32
    os.lseek(fd, 0, 0)
    assert 32 == os.write(fd, header)
    return size
  finally:
    if not isinstance(encfile_or_fd, int):
      os.close(fd)


class DecryptError(Error):
  """Raised on a crypto error when reading an encrypted file."""


class DecryptOpensslError(DecryptError):
  """Raised when openssl has failed decrypting."""


class DecryptHmacError(DecryptError):
  """Raised at a HMAC mismatch when decrypting."""


def FdPassphraseRequester(np_write_fd):
  def FdRequest():
    os.write(np_write_fd, 'W')

  return FdRequest


def InstantPassphraseRequester(pp_write_fd, passphrasen):
  def InstantRequest():
    # Not calling WriteAll, on purpose, to guarantee atomicity.
    got = os.write(pp_write_fd, passphrasen)
    assert got == len(passphrasen)

  return InstantRequest


def IsHeaderOk(header):
  """Returns true iff the file header is recognized as written by joenc1."""
  return len(header) >= 32 and (
      header.startswith(HEADER_START_NOSSHONLY) or
      header.startswith(HEADER_START_SSHONLY))


def Decrypt(encfile, passphrase_requester, passphrase_fd, need_plaintext,
            header=None):
  """Read and decrypt encfile, return the full plaintext."""
  if isinstance(encfile, int):
    fd = encfile
  else:
    fd = os.open(encfile, os.O_RDONLY)
  try:
    if header is None:
      header = os.read(fd, 32)
    if not header:
      return ''
    if not IsHeaderOk(header):
      assert 0, ('error: unrecognized header %s' %
                 header.encode('hex'))
    expected_hmac = header[12 : 32]
    passphrase_requester()
    passphrasen = os.read(passphrase_fd, 4096)
    i = passphrasen.find('\n')
    assert i == len(passphrasen) - 1
    hmac_obj = hmac.new(passphrasen[:-1], None, sha1_module)
    passphrasen = None  # Don't rememer it to olong.
    # Ask the parent to write the passphrase for openssl below.
    passphrase_requester()
    p = subprocess.Popen(
        ('openssl', 'enc', '-aes-256-cbc', '-salt', '-md', 'md5', '-d',
         '-pass', 'fd:%d' % passphrase_fd),
        stdin=fd, stdout=subprocess.PIPE)
    try:
      plaintext = []
      while 1:
        data = p.stdout.read(8192)
        if not data:
          break
        hmac_obj.update(data)
        if need_plaintext:
          plaintext.append(data)
    finally:
      exit_code = p.wait()
    got_hmac = hmac_obj.digest()
    if expected_hmac != got_hmac:
      # Don't write anything until hmac is proven correct.
      # We may also display an OpenSSL error above.
      raise DecryptHmacError
    if exit_code:
      raise DecryptOpensslError(
          'openssl decrypt failed with exit_code=%r' % exit_code)
    return ''.join(plaintext)
  finally:
    if not isinstance(encfile, int):
      os.close(fd)


def JoeFileWorker(np_write_fd, passphrase_fd, encfile, is_ssh_only):
  """Called when this program was invoked by joe through `!file'."""
  tty_fd = os.open('/dev/tty', os.O_WRONLY)
  if tty_fd != 2:
    os.dup2(tty_fd, 2)
    os.close(tty_fd)
  passphrase_requester = FdPassphraseRequester(np_write_fd)
  try:
    st0 = os.fstat(0)
    st1 = os.fstat(1)
    if stat.S_ISFIFO(st1.st_mode) and not stat.S_ISFIFO(st0.st_mode):
      WriteAll(1, Decrypt(encfile, passphrase_requester, passphrase_fd,
               True))
    elif stat.S_ISFIFO(st0.st_mode) and not stat.S_ISFIFO(st1.st_mode):
      # TODO(pts): Better write error handling.
      #open('save.dat', 'w').write(time.ctime() + '\n' + sys.stdin.read())
      Encrypt(encfile, FdSource(0), passphrase_requester, passphrase_fd,
              is_ssh_only)
      # TODO(pts): Better error reporting on assertion failure here.
    else:
      assert 0, 'error: invalid pipe invocation'
  except SystemExit:
    pass
  except:
    typ, exc, tb = sys.exc_info()
    os.close(1)
    if not os.fork():  # Report in a child process, so joe doesn't wait for it.
      time.sleep(0.3)
      if isinstance(exc, AssertionError):
        os.write(2, 'joenc1 ERROR: %s\r' % exc)
      else:
        os.write(2, 'joenc1 EXC: %s: %s\r' % (type(exc).__name__, exc))
      traceback.print_exc()
      os._exit(3)


def ShowUsage(argv):
  doc = re.sub(r'\A(?::" # ?)?', '', __doc__.strip())
  doc = re.sub(r'(?s)\ntype python.*?\n\n', '', doc, 1)
  print >>sys.stderr, ('%s\n\n%s' % (argv[0], doc))  # Module docstring.


def QuoteShellWord(word):
  """Quote a word from /bin/sh (Bourne shell)."""
  if re.match(r'[-:,@%=+/.\w][-:,~@%^={}+/.\w]*\Z', word):
    return word
  else:
    return "'%s'" % word.replace("'", "'\\''")


def FindOnPath(binary):
  if '/' in binary:
    return binary
  for dir_name in os.getenv('PATH', '/bin:/usr/bin').split(':'):
    if dir_name:
      file_name = os.path.join(dir_name, binary)
      if os.path.isfile(file_name):
        return file_name
  return None

PREP = {
    'salt1': 'foo',
    'salt2': 'bar',
    'num_iterations': 1903,
    'salt1_rsa': 'baz',
    'salt2_rsa': 'quux',
    'num_iterations_before_rsa_fix': 951,
}
"""Parameters of preprocessing."""


def PreprocessPassphrase(passphrase):
  """Return base64-encoded passphrasen with a trailing \n."""
  salt1 = PREP['salt1']
  salt2 = PREP['salt2']
  data = passphrase
  for i in xrange(PREP['num_iterations']):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  assert len(data) == 40
  passphrasen = data.encode('base64').rstrip('\n')
  assert '\n' not in passphrasen
  return passphrasen + '\n'


def PreprocessMiddle(middle):
  """Return base64-encoded passphrasen with a trailing \n."""
  salt1 = PREP['salt1']
  salt2 = PREP['salt2']
  data = middle
  n1 = PREP['num_iterations_before_rsa_fix']
  n2 = PREP['num_iterations']
  for i in xrange(n1, n2):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  assert len(data) == 40
  passphrasen = data.encode('base64').rstrip('\n')
  assert '\n' not in passphrasen
  return passphrasen + '\n'


def StrXor(s1, s2):
  # PyCrypto has a faster implementation (but Python 2.6 doesn't), but we
  # don't care much here, because we don't call StrXor in an inner loop.
  return ''.join(map(lambda x, y: chr(ord(x) ^ ord(y)), s1, s2))


def PreprocessRsaSignatureToMiddle(signature, fixup):
  """Return the binary middle."""
  assert len(signature) >= 40
  assert len(fixup) == 40
  salt1 = PREP['salt1_rsa']
  salt2 = PREP['salt2_rsa']
  data = signature[-40:]  # TODO(pts): Don't we want the whole signature?
  n1 = PREP['num_iterations_before_rsa_fix']
  n2 = PREP['num_iterations']
  # It would work (but may be cryptographically weaker with <= instead of <).
  assert 0 < n1 < n2
  for i in xrange(n1):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  assert len(data) == 40
  return StrXor(data, fixup)  # middle.


def PreprocessRsaSignature(signature, fixup):
  """Return the computed passphrasen."""
  data = PreprocessRsaSignatureToMiddle(signature, fixup)
  salt1 = PREP['salt1']
  salt2 = PREP['salt2']
  n1 = PREP['num_iterations_before_rsa_fix']
  n2 = PREP['num_iterations']
  for i in xrange(n1, n2):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  # 40 bytes before base64, 56 bytes after + 1 byte for the newline.
  passphrasen = data.encode('base64').rstrip('\n')
  assert '\n' not in passphrasen
  return passphrasen + '\n'


def PreprocessToMiddle(passphrase):
  """Compute and return the binary middle."""
  assert '\n' not in passphrase
  n1 = PREP['num_iterations_before_rsa_fix']
  salt1 = PREP['salt1']
  salt2 = PREP['salt2']
  data = passphrase
  for i in xrange(n1):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  return data  # middle.


def GetFixup(middle, signature):
  """Compute and return the binary fixup= value for the .akeys file."""
  assert len(signature) >= 40
  salt1 = PREP['salt1_rsa']
  salt2 = PREP['salt2_rsa']
  data = signature[-40:]  # TODO(pts): Don't we want the whole signature?
  n1 = PREP['num_iterations_before_rsa_fix']
  for i in xrange(n1):
    data = sha1(salt1 + data).digest() + sha1(data + salt2).digest()
  return StrXor(middle, data)


SSH2_AGENTC_REQUEST_IDENTITIES = 11
SSH2_AGENT_IDENTITIES_ANSWER = 12
SSH2_AGENTC_SIGN_REQUEST = 13
SSH2_AGENT_SIGN_RESPONSE = 14
SSH_AGENT_FAILURE = 5


def RecvAll(sock, size):
  if size == 0:
    return ''
  assert size >= 0
  if hasattr(sock, 'recv'):
    recv = sock.recv
  else:
    recv = sock.read
  data = recv(size)
  if len(data) >= size:
    return data
  assert data, 'unexpected EOF'
  output = [data]
  size -= len(data)
  while size > 0:
    output.append(recv(size))
    assert output[-1], 'unexpected EOF'
    size -= len(output[-1])
  return ''.join(output)


def RecvU32(sock):
  return struct.unpack('>L', RecvAll(sock, 4))[0]


def RecvStr(sock):
  return RecvAll(sock, RecvU32(sock))


def AppendStr(ary, data):
  assert isinstance(data, str)
  ary.append(struct.pack('>L', len(data)))
  ary.append(data)


def AppendPositive(ary, n):
  if not isinstance(n, (int, long)):
    raise TypeError
  if n < 0:
    raise ValueError
  data = '%x' % n
  if len(data) % 2 == 1:
    data = '0' + data
  elif data[0] not in '01234567':  # Large first digit --> prepend 00.
    data = '00' + data
  AppendStr(ary, data.decode('hex'))


def ConnectToSshAgent():
  """Connects to the ssh-agent and returns the client socket, or None."""
  if os.getenv('SSH_AUTH_SOCK', ''):
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
  try:
    sock.connect(os.getenv('SSH_AUTH_SOCK'))
    return sock
  except socket.error, e:
    return None


def YieldSshAgentRsaKeys(sock=None):
  if sock is None:
    sock = ConnectToSshAgent()
  if sock is not None:  # Silently ignore sock is None.
    sock.sendall('\0\0\0\1\v')  # SSH2_AGENTC_REQUEST_IDENTITIES
    response = RecvStr(sock)
    resf = cStringIO.StringIO(response)
    assert RecvAll(resf, 1) == chr(SSH2_AGENT_IDENTITIES_ANSWER)
    num_keys = RecvU32(resf)
    assert num_keys < 2000  # A quick sanity check.
    # TODO(pts): Make this work again.
    #if not num_keys:
    #  print >>sys.stderr, 'warning: no keys have_been added to ssh-agent'
    #  return None, None, None, None
    # Please note that the SSH agent in Ubuntu Lucid doesn't store the
    # original SSH key comment, but it stores the absolute local filename of
    # the private key.
    for i in xrange(num_keys):
      key = RecvStr(resf)
      comment_or_filename = RecvStr(resf)
      if not key.startswith('\x00\x00\x00\x07ssh-rsa\x00\x00'):
        continue
      keyf = cStringIO.StringIO(key[11:])
      public_exponent = int(RecvStr(keyf).encode('hex'), 16)
      modulus_str = RecvStr(keyf)
      modulus = int(modulus_str.encode('hex'), 16)
      assert '' == keyf.read(1), 'EOF expected in keyf'
      yield public_exponent, modulus, comment_or_filename
    assert '' == resf.read(1), 'EOF expected in resf'
  # TODO(pts): Do an explicit sock.close if we've just opened it.


KEYVAL_RE = re.compile(r'\s*([^\s=]+)=("([^"]*)"|\S+)')
TOKEN_RE = re.compile(r'\s*(\S+)')


def ParseRsaPublicKey(line):
  """Parses an RSA key from a line in ~/.ssh/id_*.pub or authorized_keys.

  Returns:
    A dict describing the results or None if key not found.
  """
  line = line.rstrip('\r\n')
  if line.startswith('#') or not line:
    return None
  scanner = KEYVAL_RE.scanner(line)
  i = 0
  h = {}
  while 1:
    match = scanner.match()
    if not match:
      break
    i = match.end()
    if match.group(3) is not None:
      h[match.group(1)] = match.group(3)
    else:
      h[match.group(1)] = match.group(2)
  scanner = TOKEN_RE.scanner(line, i)
  match = scanner.match()
  if not match:
    return None
  key_type = match.group(1)
  if key_type != 'ssh-rsa':
    return None
  match = scanner.match()
  if not match:
    return None
  public_key_base64 = match.group(1)
  i = match.end()
  if i < len(line) and line[i] == ' ':  # TODO(pts): Allow other whitespace?
    i += 1
  comment = line[i:]
  # Parsing succeeded, we have h, key_type, public_key_base64 and comment.

  public_key = base64.b64decode(public_key_base64)
  # Now public_key_base64 is the base64-encoded version of the public
  # key, i.e. the long word starting with AAAA... after 'ssh-rsa ' in
  # ~/.ssh/id_*.pub and ~/.ssh/authorized_keys.
  if h.get('random', '?') == '?':
    random = None
  else:
    assert re.match('[0-9a-fA-F]{80}\Z', h['random'])
    random = h['random'].decode('hex')
  if h.get('fixup', '?') == '?':
    fixup = None
  else:
    assert re.match('[0-9a-fA-F]{80}\Z', h['fixup'])
    fixup = h['fixup'].decode('hex')
  # Decode the SSH2 RSA public key.
  assert public_key.startswith('\0\0\0\7ssh-rsa\0\0')
  assert len(public_key) >= 15
  public_exponent_size = struct.unpack('>L', public_key[11 : 15])[0]
  assert len(public_key) >= 15 + public_exponent_size
  public_exponent = int(
      public_key[15 : 15 + public_exponent_size].encode('hex'), 16)
  i = 15 + public_exponent_size
  assert len(public_key) >= 4 + i
  modulus_size = struct.unpack('>L', public_key[i : i + 4])[0]
  assert len(public_key) == 4 + i + modulus_size
  modulus = int(
      public_key[4 + i : 4 + i + modulus_size].encode('hex'), 16)
  return {  # aitem.
      'comment': comment,
      'random': random,
      'fixup': fixup,
      'public_exponent': public_exponent,
      'modulus': modulus,
      'public_key_base64': public_key_base64,
  }


def GetAndVerifySignature(sock, msg_to_sign, public_exponent, modulus):
  """Ask ssh-agent to sign the message with the specified key.

  Raises an exception if the signature could not be verified.

  Returns:
    The signature with the last 40 bytes (the SHA1 hash) stripped.
  """
  # TODO(pts): What happens after reboot, with Ubuntu Lucid's GNOME's
  # ssh-agent? It fakes that it has the key added, but it can't encrypt
  # properly with it. Sigh. But maybe another key has been already added
  # properly.
  request_output = [chr(SSH2_AGENTC_SIGN_REQUEST)]
  key = ['\0\0\0\7ssh-rsa']
  AppendPositive(key, public_exponent)
  AppendPositive(key, modulus)
  key = ''.join(key)
  AppendStr(request_output, key)
  AppendStr(request_output, msg_to_sign)
  request_output.append(struct.pack('>L', 0))  # flags == 0
  full_request_output = []
  # TODO(pts): Do this without copying.
  AppendStr(full_request_output, ''.join(request_output))
  full_request_str = ''.join(full_request_output)
  sock.sendall(full_request_str)
  response = RecvStr(sock)
  resf = cStringIO.StringIO(response)
  assert RecvAll(resf, 1) == chr(SSH2_AGENT_SIGN_RESPONSE)
  signature = RecvStr(resf)
  assert '' == resf.read(1), 'EOF expected in resf'
  assert signature.startswith('\0\0\0\7ssh-rsa\0\0'), repr(signature[:16])
  sigf = cStringIO.StringIO(signature[11:])
  signature = RecvStr(sigf)
  assert len(signature) >= 80  # Much longer, e.g. 256, 512 or 1024 bytes.
  signed_value = int(signature.encode('hex'), 16)
  assert '' == sigf.read(1), 'EOF expected in sigf'
  #print repr(signed_value)  # The same for each run with the same input.

  # Verify the signature.
  decoded_value = pow(signed_value, public_exponent, modulus)
  decoded_hex = '%x' % decoded_value
  if len(decoded_hex) & 1:
    decoded_hex = '0' + decoded_hex
  decoded_str = decoded_hex.decode('hex')
  modulus_str = '%x' % modulus
  if len(modulus_str) % 2 == 1:
    modulus_str = '0' + modulus_str
  modulus_str = modulus_str.decode('hex')
  # Just a quick sanity check that decoded_value is large enough.
  # E.g. 255+2==257.
  assert len(decoded_str) - len(decoded_str) in (0, 1, 2), (
      len(decoded_str), len(modulus_str))

  assert re.match(r'\x01\xFF+\Z', decoded_str[:-36]), 'bad padding found'
  expected_sha1_hex = decoded_hex[-40:]
  msg_sha1_hex = sha1(msg_to_sign).hexdigest()
  assert expected_sha1_hex == msg_sha1_hex, 'bad signature (SHA1 mismatch)'
  return signature[:-40]


def ReadRsaInfo(encfile, is_plain_ok):
  """Return (signature, fixup, random, public_key_base64).

  Or return (None, None, None, None).

  The returned signature is verified (i.e. that the SSH agent knows the
  private key, or None.
  """
  # TODO(pts): If the key is not found in the ssh-agent, try to find it in
  # ~/.ssh/id_* (etc.), and add it to the agent (or to a tmp agent).
  # TODO(pts): Write a function which updates the fixup= field in the .akeys
  # file, possibly using GetFixup.
  akeys_filename = encfile + '.akeys'
  try:
    f = open(akeys_filename)
  except IOError:
    return None, None, None, None
  # List of aitem dictionaries, as parsed from the akeys file.
  aitems = []
  is_empty = True
  try:
    for line in f.xreadlines():
      is_empty = False
      aitem = ParseRsaPublicKey(line)
      if aitem is None:
        continue
      if is_plain_ok:
        if aitem['random'] is None:
          # TODO(pts): Make it work on systems without os.urandom.
          aitem['random'] = os.urandom(40)  # TODO(pts): Move it later.
      else:
        if aitem['random'] is None or aitem['fixup'] is None:
          continue
      aitems.append(aitem)
  finally:
    f.close()
  if not aitems:
    if not is_empty:
      print >>sys.stderr, (
          'warning: no RSA keys recognized in akeys file: %s' %
          akeys_filename)
    return None, None, None, None

  # Connect to ssh-agent.
  if not os.getenv('SSH_AUTH_SOCK', ''):
    print >>sys.stderr, 'warning: no ssh-agent to connect to'
    return None, None, None, None
  sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
  try:
    try:
      sock.connect(os.getenv('SSH_AUTH_SOCK'))
    except socket.error, e:
      print >>sys.stderr, 'warning: cannot connect to ssh-agent: %s' % e
      return None, None, None, None

    # Get list of public keys, and find our key.
    #
    # Please note that the SSH agent in Ubuntu Lucid doesn't store the
    # original SSH key comment, but it stores the absolute local filename of
    # the private key. So we just ignore comments.
    is_found = False
    for public_exponent, modulus, unused_comment_or_filename in (
        YieldSshAgentRsaKeys(sock)):
      for aitem in aitems:
        if (aitem['public_exponent'] == public_exponent and
            aitem['modulus'] == modulus):
          #assert not is_found, 'Found multiple matching keys in ssh-agent.'
          is_found = True
          found_fixup = aitem['fixup']
          found_random = aitem['random']
          found_public_key_base64 = aitem['public_key_base64']
          found_modulus = modulus
          found_public_exponent = public_exponent
          break
    if not is_found:
      print >>sys.stderr, (
          'warning: keys in ssh-agent not matching any key in: %s' %
          akeys_filename)
      return None, None, None, None

    signature = GetAndVerifySignature(
        sock, found_random, found_public_exponent, found_modulus)
    return signature, found_fixup, found_random, found_public_key_base64
  finally:
    sock.close()


def FindJoeBinaryPath():
  """Finds the joe binary on $PATH and returns the pathname, or None."""
  return (FindOnPath('joe-p37') or
          FindOnPath('joe-p35') or
          FindOnPath('joe.mc') or
          FindOnPath('joe'))


def GetMyBinaryPath(argv0):
  """Figure out and return the full path to this joenc1 binary."""
  myprog = os.path.abspath(argv0)
  assert '\0' not in myprog, repr(myprog)
  assert myprog.startswith('/'), repr(myprog)
  try:
    stp = os.stat(myprog)
  except OSError:
    print >>sys.stderr, 'error: my binary not found: %s' % myprog
    sys.exit(2)
  if not stat.S_ISREG(stp.st_mode) or (stp.st_mode & 0100) == 0:
    print >>sys.stderr, 'error: my binary is not executable: %s' % myprog
    sys.exit(2)
  return myprog


def CheckTerminals():
  """Check that stdin, stdout, stderr filehandles are good terminal devices."""
  if not os.isatty(2):
    print >>sys.stderr, 'error: stderr must be a terminal'
    sys.exit(2)
  st0 = os.fstat(0)
  st1 = os.fstat(1)
  st2 = os.fstat(2)
  # We need this check so we'll be able to distinguish between input and
  # output for joe '!joenc'.
  if ((st0.st_mode & ~07777) != (st1.st_mode & ~07777) or
      st0.st_dev != st1.st_dev):
    print >>sys.stderr, 'error: stdin and stdout are not the same terminals'
    sys.exit(2)
  if ((st0.st_mode & ~07777) != (st2.st_mode & ~07777) or
      st0.st_dev != st2.st_dev):
    print >>sys.stderr, 'error: stdin and stderr are not the same terminals'
    sys.exit(2)


def RunJoe(argv, encfile_i, encfile, pp_write_fd, passphrase_fd, passphrasen,
           joe_prog, is_ssh_only):
  """Runs joe, does not return (calls sys.exit)."""
  # TODO(pts): Check against EUID.
  if os.access(encfile, os.W_OK):
    rdonly_flag = '--rdonly'  # read-write
  else:
    rdonly_flag = '-rdonly'  # read-only

  myprog = GetMyBinaryPath(argv[0])  # Can fail.
  joe_cmd = list(argv)
  joe_cmd[0] = joe_prog
  joe_cmd[encfile_i] = '!%s %s' % (
      QuoteShellWord(myprog), QuoteShellWord(encfile))
  # TODO(pts): Don't make other files in the command-line read-only.
  joe_cmd[encfile_i : encfile_i] = [rdonly_flag]

  # The need-password pipe.
  np_read_fd, np_write_fd = os.pipe()
  fcntl.fcntl(np_read_fd, fcntl.F_SETFD,
              fcntl.fcntl(np_read_fd, fcntl.F_GETFD) | fcntl.FD_CLOEXEC)
  os.environ['JOENC1_FILE_WORKER'] = '%d:%d:%d' % (
      np_write_fd, passphrase_fd, int(bool(is_ssh_only)))

  p = subprocess.Popen(joe_cmd)
  # TODO(pts): Solve this without threads.
  thread.start_new_thread(
      ErrorWrapper, (PassphraseSender, np_read_fd, pp_write_fd, passphrasen))
  sys.exit(p.wait())


def VerifyEncrypted(encfile, passphrasen):
  """Upon failure, writes to stderr and calls sys.exit."""
  # Create passphrase pipe for openssl below.
  passphrase_fd, pp_write_fd = os.pipe()
  try:
    # passphrase_fd has ~FD_CLOEXEC by default, we don't have to change that.
    fcntl.fcntl(pp_write_fd, fcntl.F_SETFD,
                fcntl.fcntl(pp_write_fd, fcntl.F_GETFD) | fcntl.FD_CLOEXEC)
    passphrase_requester = InstantPassphraseRequester(pp_write_fd, passphrasen)
    try:
      Decrypt(encfile, passphrase_requester, passphrase_fd, False)
    except DecryptHmacError:  # TODO(pts): Remove code duplication.
      # This doesn't always detect the failure, sometimes it just decrypts
      # the wrong data, that's why we have integrity protection with the
      # hmac above.
      print >>sys.stderr, 'error: decryption failed (bad passphrase?)'
      sys.exit(5)
    except DecryptOpensslError:  # TODO(pts): Remove code duplication.
      # In addition to this error, the `openssl' command may also display a
      # decryption error above. But it doesn't always do so.
      print >>sys.stderr, 'error: hmac mismatch (bad passphrase?): %s' % (
          encfile)
      sys.exit(9)
  finally:
    os.close(pp_write_fd)
    os.close(passphrase_fd)


def PromptPassphrase(prompt):
  """Prompts the user for a non-empty passphrase, and returns it."""
  try:
    passphrase = getpass.getpass(prompt=prompt)
  except EOFError:
    print >>sys.stderr, 'info: end-of-file, exiting'
    sys.exit(4)
  except KeyboardInterrupt:
    print >>sys.stderr, 'info: interrupted, exiting'
    sys.exit(4)
  passphrase = passphrase.strip()
  if not passphrase:
    # TODO(pts): Consider allowing it if forced.
    print >>sys.stderr, 'error: empty passphrase not allowed'
    sys.exit(14)
  return passphrase


def ReplaceFile(filename, data):
  """Replace the contents of filename with data, with an atomic rename."""
  # TODO(pts): More reentrant, add PID, clean up etc.
  filename_tmp = filename + '.tmp'
  mode = os.stat(filename).st_mode & 07777
  open(filename_tmp, 'a').close()
  os.chmod(filename_tmp, mode)
  f = open(filename_tmp, 'a')
  try:
    f.write(data)
  finally:
    f.close()
  os.rename(filename_tmp, filename)


def CheckNotSshOnly(is_ssh_only, encfile):
  """Exits with an error message on SSH-only files."""
  if is_ssh_only:
    print >>sys.stderr, (
        'error: SSH key not available, file has no passphrase: %s' % encfile)
    print >>sys.stderr, 'info: does the right key show up in?: ssh-add -L'
    sys.exit(15)


def main(argv):
  if (os.getenv('JOENC1_FILE_WORKER', None) is not None and
      len(sys.argv) == 2):
    np_write_fd, passphrase_fd, is_ssh_only = map(
        int, os.getenv('JOENC1_FILE_WORKER').split(':', 2))
    is_ssh_only = bool(is_ssh_only)
    sys.exit(JoeFileWorker(
        np_write_fd, passphrase_fd, sys.argv[1], is_ssh_only))

  argv = list(argv)

  if len(argv) <= 1 or argv[1] == '--help':
    ShowUsage(argv)
    sys.exit(0)

  do_create = False  # Do create if doesn't exist, don't start joe.
  do_encrypt = False
  do_decrypt = False
  do_create_with_key = False
  key_to_add = None
  i = 1
  while i < len(argv):
    arg = argv[i]
    if arg in ('-create', '--create'):
      do_create = True
    elif arg in ('-encrypt', '--encrypt'):
      do_encrypt = True
    elif arg in ('-decrypt', '--decrypt'):
      do_decrypt = True
    elif arg in ('-create-with-key', '--create-with-key') and (
        i + 1 < len(argv)):
      do_create_with_key = True
      i += 1
      key_to_add = argv[i]
    elif arg == '--':
      i += 1
      break
    elif not arg.startswith('-') or arg == '-':
      break
    i += 1
  if i >= len(argv):
    if do_encrypt or do_decrypt:
      encfile = '-'
      encfile_i = None
    else:
      print >>sys.stderr, 'error: encfile not specified'
      ShowUsage(argv)
      sys.exit(1)
  else:
    encfile = argv[i]
    encfile_i = i
    i += 1
  if (do_encrypt or do_decrypt) and i < len(argv):
    print >>sys.stderr, 'error: too many command-line arguments'
    ShowUsage(argv)
    sys.exit(1)
  dosum = do_create + do_encrypt + do_decrypt + do_create_with_key
  do_run_joe = not dosum
  if do_run_joe + dosum != 1:
    print >>sys.stderr, 'error: invalid combination of action flags'
    ShowUsage(argv)
    sys.exit(1)
  if do_create_with_key:
    do_create = True
  #if key_to_add is not None:
  if encfile == '-' and not (do_encrypt or do_decrypt):
    print >>sys.stderr, 'error: cannot use stding for this action'
    ShowUsage(argv)
    sys.exit(1)

  if encfile == '-':
    encfile_or_fd = 0
    if do_encrypt:
      header = None
    else:
      header = os.read(encfile_or_fd, 32)
  else:
    encfile_or_fd = encfile
    is_new = False
    try:
      ste = os.stat(encfile)
    except OSError, e:
      if e[0] == errno.ENOENT and (do_create or do_encrypt):
        fd = os.open(encfile, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0644)
        try:
          ste = os.fstat(fd)
        finally:
          os.close(fd)
        is_new = True
      elif do_decrypt:
        print >>sys.stderr, 'error: encfile not found: %s' % encfile
        sys.exit(2)
      else:
        print >>sys.stderr, (
            'error: encfile not found, create it: %s --create %s' %
            (argv[0], encfile))
        sys.exit(2)
    if not stat.S_ISREG(ste.st_mode):
      print >>sys.stderr, 'error: encfile is not a regular file: %s' % encfile
      sys.exit(2)
    fd = os.open(encfile, os.O_RDONLY)
    try:
      header = os.read(fd, 32)
    finally:
      if do_decrypt:
        encfile_or_fd = fd
      else:
        os.close(fd)
  if header:  # Non-empty file.
    if header == HEADER_IN_PROGRESS:
      # TODO(pts): Make sure this can't happen, do autorecovery.
      print >>sys.stderr, (
          'error: previous joenc1 died while saving: %s' %
          (header.encode('hex'), encfile))
      sys.exit(8)
    if not IsHeaderOk(header):
      print >>sys.stderr, (
          'error: unrecognized joenc1 header %s in file: %s' %
          (header.encode('hex'), encfile))
      sys.exit(8)
    is_ssh_only = header.startswith(HEADER_START_SSHONLY)
  else:
    is_ssh_only = do_create_with_key

  signature = fixup = random = public_key_base64 = None
  if key_to_add is not None:
    f = open(key_to_add)
    try:
      data = f.read()
    finally:
      f.close()
    if data.startswith('-----BEGIN ') and not key_to_add.endswith('.pub'):
      # Found an SSH2 private key.
      key_to_add += '.pub'
      f = open(key_to_add)
      try:
        data = f.read()
      finally:
        f.close()
    aitems = filter(None, map(ParseRsaPublicKey, data.split('\n')))
    if not aitems:
      print >>sys.stderr, 'error: SSH2 RSA public key not found in: %s' % (
          key_to_add)
      sys.exit(11)
    if len(aitems) > 1:
      print >>sys.stderr, (
          'error: multiple SSH2 RSA public keys found in: %s' % key_to_add)
      sys.exit(11)
    is_found = False
    sock = ConnectToSshAgent()
    if sock is None:
      print >>sys.stderr, 'error: could not connect to ssh-agent'
      sys.exit(13)
    try:
      for public_exponent, modulus, unused_comment_or_filename in (
          YieldSshAgentRsaKeys(sock)):
        if (public_exponent == aitems[0]['public_exponent'] and
            modulus == aitems[0]['modulus']):
          is_found = True
      if not is_found:
        print >>sys.stderr, 'info: Adding key to ssh-agent.'
        assert key_to_add.endswith('.pub'), repr(key_to_add)
        private_key_fn = key_to_add[:-4]  # Remove trailing '.pub'.
        exit_code = subprocess.call(('ssh-add', '--', private_key_fn))
        if exit_code:
          print >>sys.stderr, 'error: ssh-add failed: exit_code=%d' % exit_code
          sys.exit(12)
      middle = None
      open(encfile + '.akeys', 'a').close()
      signature, fixup, random, public_key_base64 = ReadRsaInfo(
          encfile, False)
      if signature is not None:  # Found a working private key in ssh-agent.
        middle = PreprocessRsaSignatureToMiddle(signature, fixup)
      signature = fixup = random = public_key_base64 = None
      need_verify = True
      if middle is None:
        if header:
          CheckNotSshOnly(is_ssh_only, encfile)
          passphrase = PromptPassphrase('joenc1 passphrase of %r: ' % encfile)
        else:
          print >>sys.stderr, 'info: generating random passphrase'
          # 88 printable bytes, without a newline.
          passphrase = os.urandom(66).encode('base64').replace('\n', '')
          need_verify = False
        middle = PreprocessToMiddle(passphrase)
        del passphrase
      if need_verify:
        # TODO(pts): Don't verify it again later.
        VerifyEncrypted(encfile, PreprocessMiddle(middle))

      # Use the existing keys to add the new key.
      random = os.urandom(40)
      signature = GetAndVerifySignature(
          sock, random, aitems[0]['public_exponent'], aitems[0]['modulus'])
      # TODO(pts): Add other key--value fields in key_to_add?
      assert signature and len(signature) >= 40
      fixup = GetFixup(middle, signature)
      assert PreprocessMiddle(middle) == PreprocessRsaSignature(
          signature, fixup)
      del middle
      # Keep signature for below.
      pattern = ' ssh-rsa %s ' % aitems[0]['public_key_base64']
      akeys_line = 'fixup=%s random=%s ssh-rsa %s %s\n' % (
          fixup.encode('hex'), random.encode('hex'),
          aitems[0]['public_key_base64'], aitems[0]['comment'])
      f = open(encfile + '.akeys')
      is_found = False
      try:
        lines = []
        for line in f:
          if pattern in line.rstrip('\n') + ' ':
            is_found = True
            break
          lines.append(line)
      finally:
        f.close()
      if is_found:
        # TODO(pts): Make sure it's valid. If not, refresh.
        print >>sys.stderr, 'info: key already in key file: %s.akeys' % encfile
      else:
        print >>sys.stderr, 'info: extending key file: %s.akeys' % encfile
        if lines and not lines[-1].endswith('\n'):
          lines[-1] += '\n'
        lines.append(akeys_line)
        ReplaceFile(encfile + '.akeys', ''.join(lines))
        del lines
      del akeys_line
    finally:
      sock.close()
      del sock

  if do_run_joe:
    CheckTerminals()
    joe_prog = FindJoeBinaryPath()
    if not joe_prog:
      print >>sys.stderr, 'error: joe: command not found'
      sys.exit(7)

  if signature is None and header:
    signature, fixup, random, public_key_base64 = ReadRsaInfo(encfile, False)

  if signature is None:
    CheckNotSshOnly(is_ssh_only, encfile)
    if not header:
      if encfile == '-':
        prompt = 'joenc1 encrypt passphrase of stdin: '
      elif is_new:
        prompt = 'joenc1 new passphrase of new %r: ' % encfile
      else:
        prompt = 'joenc1 new passphrase of empty %r: ' % encfile
    elif encfile == '-':
      prompt = 'joenc1 decrypt passphrase of stdin: '
    else:
      prompt = 'joenc1 passphrase of %r: ' % encfile
    passphrase = PromptPassphrase(prompt)
    passphrasen = PreprocessPassphrase(passphrase)
    if not header:  # Empty file.
      try:
        passphrase_again = getpass.getpass(prompt='joenc1 passphrase again: ')
      except EOFError:
        print >>sys.stderr, 'end-of-file, exiting'
        sys.exit(4)
      except KeyboardInterrupt:
        print >>sys.stderr, 'interrupted, exiting'
        sys.exit(4)
      passphrase_again = passphrase_again.strip()
      if passphrase_again != passphrase:
        print >>sys.stderr, 'error: new passphrase mismatch'
        sys.exit(6)
      del passphrase_again
    del passphrase
  else:
    if not do_decrypt:
      print >>sys.stderr, 'info: using RSA key'
    passphrasen = PreprocessRsaSignature(signature, fixup)

  # Create passphrase pipe for openssl below.
  passphrase_fd, pp_write_fd = os.pipe()
  # passphrase_fd has ~FD_CLOEXEC by default, we don't have to change that.
  fcntl.fcntl(pp_write_fd, fcntl.F_SETFD,
              fcntl.fcntl(pp_write_fd, fcntl.F_GETFD) | fcntl.FD_CLOEXEC)
  passphrase_requester = InstantPassphraseRequester(pp_write_fd, passphrasen)

  if not header and (do_create or do_run_joe):
    Encrypt(encfile, (), passphrase_requester, passphrase_fd, is_ssh_only)
    print >>sys.stderr, 'info: created with empty plaintext: %s' % encfile

  try:
    if do_decrypt:
      # Don't write anything until verified.
      plaintext = Decrypt(encfile_or_fd, passphrase_requester,
                          passphrase_fd, True, header=header)
      WriteAll(1, plaintext)
    elif do_encrypt and encfile == '-':
      pass
    else:
      # We decrypt first even with do_encrypt, to verify that that
      # passphrase is correct for a possibly preexisting encfile.
      # !! do_encrypt?
      Decrypt(encfile, passphrase_requester, passphrase_fd, False)
  except DecryptHmacError:
    # This doesn't always detect the failure, sometimes it just decrypts the
    # wrong data, that's why we have integrity protection with the hmac above.
    print >>sys.stderr, 'error: decryption failed (bad passphrase?)'
    sys.exit(5)
  except DecryptOpensslError:
    # In addition to this error, the `openssl' command may also display a
    # decryption error above. But it doesn't always do so.
    print >>sys.stderr, 'error: hmac mismatch (bad passphrase?): %s' % (
        encfile)
    sys.exit(9)

  if do_run_joe:
    RunJoe(argv, encfile_i, encfile, pp_write_fd, passphrase_fd, passphrasen,
           joe_prog, is_ssh_only)
  elif do_create:
    if header:
      print >>sys.stderr, 'info: encfile verified OK, kept intact: %s' % (
          encfile)
  elif do_encrypt:
    if encfile == '-':
      encfile_or_fd = 1
    else:
      encfile_or_fd = encfile
    size = Encrypt(encfile_or_fd, FdSource(0), passphrase_requester,
                   passphrase_fd, is_ssh_only)
    print >>sys.stderr, 'info: encrypted %d plaintext bytes to: %s' % (
        size, encfile)

  # TODO(pts): Close pp_write_fd etc.


if __name__ == '__main__':
  sys.exit(main(sys.argv))
